<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TsSoft.Expressions.Helpers</name>
    </assembly>
    <members>
        <member name="T:TsSoft.Expressions.Helpers.Async.AsyncHelper">
            <summary>
            Хелпер для выполнения асинхронных задач синхронно
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Async.AsyncHelper.RunSync(System.Func{System.Threading.Tasks.Task})">
            <summary>
                Выполняет задачу синхронно
            </summary>
            <param name="task">Делегат, возвращающий задачу</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Async.AsyncHelper.RunSync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
                Выполняет задачу синхронно
            </summary>
            <typeparam name="T">Тип объекта, который возвращает задача</typeparam>
            <param name="task">задача</param>
            <returns>Объект, который вернула задача</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Closures.Closure">
            <summary>
            Замыкание
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Closures.Closure.Objects">
            <summary>
            Объекты в замыкании
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Closures.IInnerLambdaCompiler">
            <summary>
            Превращает выражение с внутренней лямбдой в выражение со скомпилированным делегатом
            во избежание медленных вызовов Delegate.CreateDelegate, появляющихся при компиляции лямбды с внутренними лямбдами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.IInnerLambdaCompiler.GenerateExpressionWithCompiledLambda(System.Linq.Expressions.LambdaExpression,System.Collections.Generic.ISet{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Сгенерировать выражение со скомпилированным делегатом из лямбды
            </summary>
            <param name="lambda">Дерево лямбда-выражения</param>
            <param name="openParams">Несобственные параметры лямбды</param>
            <returns>Выражение того же типа, что исходная лямбда</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Closures.ILambdaCompiler">
            <summary>
            Компилирует лямбда-выражения, предварительно компилируя внутренние лямбды
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.ILambdaCompiler.Compile``1(System.Linq.Expressions.Expression{``0},TsSoft.Expressions.Helpers.Closures.LambdaCompilationType)">
            <summary>
            Скомпилировать лямбда-выражение
            </summary>
            <typeparam name="T">Тип делегата</typeparam>
            <param name="lambda">Лямбда-выражение</param>
            <param name="compilationType">Настройки компиляции</param>
            <returns>Делегат</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.ILambdaCompiler.Compile(System.Linq.Expressions.LambdaExpression,TsSoft.Expressions.Helpers.Closures.LambdaCompilationType)">
            <summary>
            Скомпилировать лямбда-выражение
            </summary>
            <param name="lambda">Лямбда-выражение</param>
            <param name="compilationType">Настройки компиляции</param>
            <returns>Делегат</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Closures.IMethodBuilderLambdaCompiler">
            <summary>
            Компилирует лямбду в метод в динамической сборке
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.IMethodBuilderLambdaCompiler.Compile``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Компилировать лямбду в метод в динамической сборке
            </summary>
            <typeparam name="T">Тип делегата лямбды</typeparam>
            <param name="lambda">Лямбда-выражение</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.IMethodBuilderLambdaCompiler.Compile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Компилировать лямбду в метод в динамической сборке
            </summary>
            <param name="lambda">Лямбда-выражение</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Closures.InnerLambdaCompiler">
            <summary>
            Превращает выражение с внутренней лямбдой в выражение со скомпилированным делегатом
            во избежание медленных вызовов Delegate.CreateDelegate, появляющихся при компиляции лямбды с внутренними лямбдами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.InnerLambdaCompiler.#ctor(TsSoft.Expressions.Helpers.Reflection.IDelegateTypeHelper)">
            <summary>
            Превращает выражение с внутренней лямбдой в выражение со скомпилированным делегатом
            во избежание медленных вызовов Delegate.CreateDelegate, появляющихся при компиляции лямбды с внутренними лямбдами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.InnerLambdaCompiler.GenerateExpressionWithCompiledLambda(System.Linq.Expressions.LambdaExpression,System.Collections.Generic.ISet{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Сгенерировать выражение со скомпилированным делегатом из лямбды
            </summary>
            <param name="lambda">Дерево лямбда-выражения</param>
            <param name="openParams">Несобственные параметры лямбды</param>
            <returns>Выражение того же типа, что исходная лямбда</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Closures.ISpecialInnerLambdaCompiler">
            <summary>
            Превращает выражение с внутренней лямбдой в выражение со скомпилированным делегатом для некоторых часто встречающихся типов делегатов
            во избежание медленных вызовов Delegate.CreateDelegate, появляющихся при компиляции лямбды с внутренними лямбдами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.ISpecialInnerLambdaCompiler.TryGenerateExpressionWithCompiledLambda(System.Linq.Expressions.LambdaExpression,System.Collections.Generic.ISet{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Попытаться сгенерировать выражение со скомпилированным делегатом из лямбды
            </summary>
            <param name="lambda">Дерево лямбда-выражения</param>
            <param name="openParams">Несобственные параметры лямбды</param>
            <returns>Выражение того же типа, что исходная лямбда (исходная лямбда в случае, если тип делегата в ней не поддерживается)</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Closures.LambdaCompilationType">
            <summary>
            Настройки компиляции лямбды
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Closures.LambdaCompilationType.PrecompileInner">
            <summary>
            Компилировать внутренние лямбды перед компиляцией внешней
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Closures.LambdaCompilationType.PrecompileInnerSpecial">
            <summary>
            Компилировать внутренние лямбды перед компиляцией внешней для фиксированного набора типов делегатов
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Closures.LambdaCompilationType.PrecompileInnerWithoutOpenParams">
            <summary>
            Компилировать внутренние лямбды, в теле которых не встречается чужих параметров
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Closures.LambdaCompilationType.DoNotPrecompile">
            <summary>
            Не компилировать внутренние лямбды перед внешней
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Closures.LambdaCompilationType.CompileToMethod">
            <summary>
            Компилировать в <see cref="T:System.Reflection.Emit.MethodBuilder"/> вместо <see cref="T:System.Reflection.Emit.DynamicMethod"/>
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Closures.MethodBuilderLambdaCompiler">
            <summary>
            Компилирует лямбду в метод в динамической сборке
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.MethodBuilderLambdaCompiler.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper)">
            <summary>
            Компилирует лямбду в метод в динамической сборке
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.MethodBuilderLambdaCompiler.Compile``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Компилировать лямбду в метод в динамической сборке
            </summary>
            <typeparam name="T">Тип делегата лямбды</typeparam>
            <param name="lambda">Лямбда-выражение</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Closures.MethodBuilderLambdaCompiler.Compile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Компилировать лямбду в метод в динамической сборке
            </summary>
            <param name="lambda">Лямбда-выражение</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Collections.CollectionHelper">
            <summary>
            Хелпер для работы с коллекциями
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.CollectionHelper.NotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Вернуть исходную коллекцию или пустую, если пришёл null
            </summary>
            <typeparam name="TElement">Тип элемента коллекции</typeparam>
            <param name="input">Исходная коллекция</param>
            <returns>Коллекция, не являющаяся null</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.CollectionHelper.IsPrefix``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Определить, является ли коллекция префиксом другой
            </summary>
            <typeparam name="TElement">Тип элемента коллекции</typeparam>
            <param name="sequence">Коллекция</param>
            <param name="prefixCandidate">Коллекция-кандидат на префикс</param>
            <param name="equalityComparer">Сравнитель элементов</param>
            <returns>Является ли кандидат префиксом</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.CollectionHelper.IsPrefixAndNotEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Определить, является ли коллекция собственным префиксом другой
            </summary>
            <typeparam name="TElement">Тип элемента коллекции</typeparam>
            <param name="sequence">Коллекция</param>
            <param name="prefixCandidate">Коллекция-кандидат на префикс</param>
            <param name="equalityComparer">Сравнитель элементов</param>
            <returns>Является ли кандидат собственным префиксом</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Collections.ICollectionHelper">
            <summary>
            Хелпер для работы с коллекциями
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.ICollectionHelper.NotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Вернуть исходную коллекцию или пустую, если пришёл null
            </summary>
            <typeparam name="TElement">Тип элемента коллекции</typeparam>
            <param name="input">Исходная коллекция</param>
            <returns>Коллекция, не являющаяся null</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.ICollectionHelper.IsPrefix``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Определить, является ли коллекция префиксом другой
            </summary>
            <typeparam name="TElement">Тип элемента коллекции</typeparam>
            <param name="sequence">Коллекция</param>
            <param name="prefixCandidate">Коллекция-кандидат на префикс</param>
            <param name="equalityComparer">Сравнитель элементов</param>
            <returns>Является ли кандидат префиксом</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.ICollectionHelper.IsPrefixAndNotEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Определить, является ли коллекция собственным префиксом другой
            </summary>
            <typeparam name="TElement">Тип элемента коллекции</typeparam>
            <param name="sequence">Коллекция</param>
            <param name="prefixCandidate">Коллекция-кандидат на префикс</param>
            <param name="equalityComparer">Сравнитель элементов</param>
            <returns>Является ли кандидат собственным префиксом</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Collections.ITreeHelper">
            <summary>
                Хелпер для работы с древесными структурами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.ITreeHelper.ConstructTreeStructureStable``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Nullable{``1}},System.Action{``0,``0},System.Func{``0,System.Collections.Generic.ICollection{``0}})">
            <summary>
                Заполняет навигационные поля сущности с древесной структурой, сохраняя исходный порядок элементов
            </summary>
            <typeparam name="T">Сущность</typeparam>
            <typeparam name="TId">Тип идентификатора сущности (уникального для сущности)</typeparam>
            <param name="treeElements">Выбранные сущности</param>
            <param name="idSelector">Функция, возвращающая идентификатор сущности</param>
            <param name="parentIdSelector">Функция, возвращающая идентификатор родителя сущности</param>
            <param name="parentSetter">Функция, заполняющая поле родителя сущности ( (child, parent) => child.Parent = parent )</param>
            <param name="childrenCollectionSelector">Функция, возвращающая коллекцию детей сущности</param>
            <returns>Сущности с заполненными навигационными полями</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.ITreeHelper.ConstructTreeStructure``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Nullable{``1}},System.Action{``0,``0},System.Func{``0,System.Collections.Generic.ICollection{``0}})">
            <summary>
                Заполняет навигационные поля сущности с древесной структурой
            </summary>
            <typeparam name="T">Сущность</typeparam>
            <typeparam name="TId">Тип идентификатора сущности (уникального для сущности)</typeparam>
            <param name="treeElements">Выбранные сущности</param>
            <param name="idSelector">Функция, возвращающая идентификатор сущности</param>
            <param name="parentIdSelector">Функция, возвращающая идентификатор родителя сущности</param>
            <param name="parentSetter">Функция, заполняющая поле родителя сущности ( (child, parent) => child.Parent = parent )</param>
            <param name="childrenCollectionSelector">Функция, возвращающая коллекцию детей сущности</param>
            <returns>Сущности с заполненными навигационными полями</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.ITreeHelper.Find``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.ICollection{``0}},System.Func{``0,System.Boolean})">
            <summary>
                Поиск листа в дереве. При нахождении листа, в его детях не ищет
            </summary>
            <typeparam name="T">Сущность</typeparam>
            <param name="treeElements">Выбранные сущности</param>
            <param name="childrenCollectionSelector">Функция, возвращающая коллекцию детей сущности</param>
            <param name="functor">Функция проверки соответствия условию</param>
            <returns></returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.ITreeHelper.OrderByHierarchy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``2},System.Func{``0,System.Nullable{``2}},System.Func{``0,System.Collections.Generic.ICollection{``0}},System.Action{``0,``0},System.Func{``0,``1},System.Action{``0},System.Collections.Generic.IComparer{``1})">
            <summary>
                Сортирует элементы древесной структуры в виде плоского дерева (1, 2, 3, 1.1, 1.1.2,2.1) -> (1, 1.1, 1.1.2, 2, 2.1, 3)
            </summary>
            <typeparam name="T">Сущность</typeparam>
            <typeparam name="TF">Поле для сортировки</typeparam>
            <typeparam name="TId">Идентификатор сущности</typeparam>
            <param name="treeElements"></param>
            <param name="idSelector">Функция, возвращающая идентификатор сущности</param>
            <param name="parentIdSelector">Функция, возвращающая идентификатор родителя сущности</param>
            <param name="parentSetter">Функция, заполняющая поле родителя сущности ( (child, parent) => child.Parent = parent )</param>
            <param name="childrenCollectionSelector">Функция, возвращающая коллекцию детей сущности</param>
            <param name="compareFieldSelector">Селектор поля, по которому идет сортировка</param>
            <param name="postprocessor">Постпроцессор отсортированных сущностей</param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Collections.ITreeHelper.Flat``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Nullable{``1}},System.Func{``0,System.Collections.Generic.ICollection{``0}},System.Action{``0,``0})">
            <summary>
                Уплощает древовидную структуру
            </summary>
            <typeparam name="T">Сущность</typeparam>
            <typeparam name="TId">Идентификатор сущности</typeparam>
            <param name="treeElements"></param>
            <param name="idSelector">Функция, возвращающая идентификатор сущности</param>
            <param name="parentIdSelector">Функция, возвращающая идентификатор родителя сущности</param>
            <param name="parentSetter">Функция, заполняющая поле родителя сущности ( (child, parent) => child.Parent = parent )</param>
            <param name="childrenCollectionSelector">Функция, возвращающая коллекцию детей сущности</param>
            <returns>Уплощенное дерево</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation">
            <summary>
            Реализация методов из System.Data.Entity.DbFunctions
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.Left(System.String,System.Nullable{System.Int64})">
            <summary>
            Отрезать часть строки слева
            </summary>
            <param name="stringArgument">Строка</param>
            <param name="length">Длина отрезаемого куска</param>
            <returns>Отрезанный кусок</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.Right(System.String,System.Nullable{System.Int64})">
            <summary>
            Отрезать часть строки справа
            </summary>
            <param name="stringArgument">Строка</param>
            <param name="length">Длина отрезаемого куска</param>
            <returns>Отрезанный кусок</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.Reverse(System.String)">
            <summary>
            Отразить строку зеркально
            </summary>
            <param name="stringArgument">Строка</param>
            <returns>Отражённая строка</returns>
            <remarks>Так же, как и SQL Server, криво работает со строками, в которых есть символы из двух UTF-16 code unit-ов (как комбинаторы, так и суррогатные пары)</remarks>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.GetTotalOffsetMinutes(System.Nullable{System.DateTimeOffset})">
            <summary>
            Получить разницу временных зон данного времени и UTC в минутах
            </summary>
            <param name="dateTimeOffsetArgument">Время с временной зоной</param>
            <returns>Разница заданной временной зоны и UTC в минутах</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.TruncateTime(System.Nullable{System.DateTimeOffset})">
            <summary>
            Удалить время из даты
            </summary>
            <param name="dateValue">Дата</param>
            <returns>Дата с обнулённым временем</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.TruncateTime(System.Nullable{System.DateTime})">
            <summary>
            Удалить время из даты
            </summary>
            <param name="dateValue">Дата</param>
            <returns>Дата с обнулённым временем</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.CreateDateTime(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double})">
            <summary>
            Создать дату
            </summary>
            <param name="year">Год</param>
            <param name="month">Месяц</param>
            <param name="day">День</param>
            <param name="hour">Час</param>
            <param name="minute">Минута</param>
            <param name="second">Секунда</param>
            <returns>Созданная дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.CreateDateTimeOffset(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Int32})">
            <summary>
            Создать дату
            </summary>
            <param name="year">Год</param>
            <param name="month">Месяц</param>
            <param name="day">День</param>
            <param name="hour">Час</param>
            <param name="minute">Минута</param>
            <param name="second">Секунда</param>
            <param name="timeZoneOffset">Разница между временной зоной даты и UTC</param>
            <returns>Созданная дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.CreateTime(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double})">
            <summary>
            Создать временной промежуток
            </summary>
            <param name="hour">Час</param>
            <param name="minute">Минута</param>
            <param name="second">Секунда</param>
            <returns>Созданный временной промежуток</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddYears(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="dateValue">Дата</param>
            <param name="addValue">На сколько лет смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddYears(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="dateValue">Дата</param>
            <param name="addValue">На сколько лет смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMonths(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="dateValue">Дата</param>
            <param name="addValue">На сколько месяцев смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMonths(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="dateValue">Дата</param>
            <param name="addValue">На сколько лет смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddDays(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="dateValue">Дата</param>
            <param name="addValue">На сколько дней смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddDays(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="dateValue">Дата</param>
            <param name="addValue">На сколько дней смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddHours(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько часов смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddHours(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько часов смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddHours(System.Nullable{System.TimeSpan},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько часов смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMinutes(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько минут смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMinutes(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько минут смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMinutes(System.Nullable{System.TimeSpan},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько минут смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddSeconds(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько секунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddSeconds(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько секунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddSeconds(System.Nullable{System.TimeSpan},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько секунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMilliseconds(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько миллисекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMilliseconds(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько миллисекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMilliseconds(System.Nullable{System.TimeSpan},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько миллисекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMicroseconds(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько микросекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMicroseconds(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько микросекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddMicroseconds(System.Nullable{System.TimeSpan},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько микросекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddNanoseconds(System.Nullable{System.DateTimeOffset},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько наносекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddNanoseconds(System.Nullable{System.DateTime},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько наносекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.AddNanoseconds(System.Nullable{System.TimeSpan},System.Nullable{System.Int32})">
            <summary>
            Сместить дату
            </summary>
            <param name="timeValue">Дата</param>
            <param name="addValue">На сколько наносекунд смещать</param>
            <returns>Смещённая дата</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.DiffYears(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset})">
            <summary>
            Получить разницу между датами в годах
            </summary>
            <param name="dateValue1">Первая дата</param>
            <param name="dateValue2">Вторая дата</param>
            <returns>Разница</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DbFunctions.DbFunctionsImplementation.DiffYears(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Получить разницу между датами в годах
            </summary>
            <param name="dateValue1">Первая дата</param>
            <param name="dateValue2">Вторая дата</param>
            <returns>Разница</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Differences.IDiffComputer">
            <summary>
            Вычисляет различия между объектами и коллекциями
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Differences.IDiffComputer.GetDiff``1(``0,``0,TsSoft.Expressions.Helpers.Differences.IEqualityComparerProvider)">
            <summary>
            Получить различия между объектами
            </summary>
            <typeparam name="T">Тип объектов</typeparam>
            <param name="first">Первый объект</param>
            <param name="second">Второй объект</param>
            <param name="equality">Как находить совпадающие объекты в коллекциях</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Differences.IDiffComputer.GetCollectionDiff``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},TsSoft.Expressions.Helpers.Differences.IEqualityComparerProvider)">
            <summary>
            Получить различия между коллекциями
            </summary>
            <typeparam name="T">Тип объектов в коллекции</typeparam>
            <param name="first">Первая коллекция</param>
            <param name="second">Вторая коллекция</param>
            <param name="equality">Как находить совпадающие объекты в коллекциях</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Differences.IEqualityComparerProvider">
            <summary>
            Предоставляет сравнители на равенство для произвольного типа
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Differences.IEqualityComparerProvider.GetEqualityComparer``1">
            <summary>
            Получить сравнитель на равенство для типа
            </summary>
            <typeparam name="T">Тип объектов</typeparam>
            <returns>Сравнитель на равенство</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer">
            <summary>
            Базовый класс для генератора динамических типов
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.ModuleBuilder">
            <summary>
            Динамический модуль
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.AssemblyBuilder">
            <summary>
            Динамическая сборка
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.#ctor(System.String)">
            <summary>
            Создать контейнер динамической сборки
            </summary>
            <param name="dynamicAssemblyName">Имя динамической сборки</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.SaveAssembly">
            <summary>
            Сохранить сборку с динамическими типами
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.PublicClass">
            <summary>
            Атрибуты для публичного класса
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.PublicInterface">
            <summary>
            Атрибуты для публичного интерфейса
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.DefineTypeWithGuidSuffix(System.String)">
            <summary>
            Создать тип с именем с уникальным суффиксом
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.DefineTypeWithGuidSuffix(System.String,System.Reflection.TypeAttributes)">
            <summary>
            Создать тип с именем с уникальным суффиксом
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.AssemblyBuilderContainer.DefineTypeWithGuidSuffix(System.String,System.Reflection.TypeAttributes,System.Type)">
            <summary>
            Создать тип с именем с уникальным суффиксом
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.DynamicTypes.IInterfaceImplementationCreator">
            <summary>
            Строит типы, реализующие заданный интерфейс со свойствами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.IInterfaceImplementationCreator.CreateInterfaceImplementation``1">
            <summary>
            Создать динамическую реализацию интерфейса
            </summary>
            <typeparam name="TInterface">Публичный интерфейс, в котором содержатся только свойства</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.IInterfaceImplementationCreator.CreateInterfaceImplementation(System.Type)">
            <summary>
            Создать динамическую реализацию интерфейса
            </summary>
            <param name="interfaceType">Публичный интерфейс, в котором содержатся только свойства</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.IInterfaceImplementationCreator.CreateInterfaceImplementation(System.Type[])">
            <summary>
            Создать динамическую реализацию нескольких интерфейсов
            </summary>
            <param name="interfaceTypes">Публичные интерфейсы, в которых содержатся только свойства</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.DynamicTypes.IInterfaceImplementationProvider">
            <summary>
            Предоставляет динамические реализации интерфейсов, кэшируя их
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.IInterfaceImplementationProvider.GetInterfaceImplementation(System.Type)">
            <summary>
            Получить динамическую реализацию интерфейса
            </summary>
            <param name="interfaceType">Публичный интерфейс, содержащий только свойства</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.DynamicTypes.InterfaceImplementationCreator">
            <summary>
            Строит типы, реализующие заданный интерфейс со свойствами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.InterfaceImplementationCreator.#ctor(TsSoft.Expressions.Helpers.DynamicTypes.IPropertyCreator)">
            <summary>
            Строит типы, реализующие заданный интерфейс со свойствами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.InterfaceImplementationCreator.CreateInterfaceImplementation``1">
            <summary>
            Создать динамическую реализацию интерфейса
            </summary>
            <typeparam name="TInterface">Публичный интерфейс, в котором содержатся только свойства</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.InterfaceImplementationCreator.AddInterfaceProperties(System.Reflection.Emit.TypeBuilder,System.Type)">
            <summary>
            Добавить в тип свойства интерфейса
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.InterfaceImplementationCreator.CreateInterfaceImplementation(System.Type)">
            <summary>
            Создать динамическую реализацию интерфейса
            </summary>
            <param name="interfaceType">Публичный интерфейс, в котором содержатся только свойства</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.InterfaceImplementationCreator.CreateInterfaceImplementation(System.Type[])">
            <summary>
            Создать динамическую реализацию нескольких интерфейсов
            </summary>
            <param name="interfaceTypes">Публичные интерфейсы, в которых содержатся только свойства</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.DynamicTypes.IPropertyCreator">
            <summary>
            Создаёт свойства в динамических типах
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.IPropertyCreator.CreateAutoProperty(System.Reflection.Emit.TypeBuilder,System.Type,System.String)">
            <summary>
            Создать свойство, скрывающее поле
            </summary>
            <param name="type">Тип, в котором создаётся свойство</param>
            <param name="propertyType">Тип свойства</param>
            <param name="propertyName">Имя свойства</param>
            <returns>Построенное свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.IPropertyCreator.DefineProperty(System.Reflection.Emit.TypeBuilder,System.Type,System.String)">
            <summary>
            Определить свойство в типе (например, в интерфейсе)
            </summary>
            <param name="type">Тип</param>
            <param name="propertyType">Тип свойства</param>
            <param name="propertyName">Имя свойства</param>
            <returns>Определённое свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.IPropertyCreator.MakeWriteableShadow(System.Reflection.Emit.TypeBuilder,System.Type,System.String,System.String)">
            <summary>
            Переопределить геттер виртуального свойства (без сеттера), выдавая из него значение другого свойства с сеттером
            </summary>
            <param name="type">Строящийся тип</param>
            <param name="propertyType">Тип свойства</param>
            <param name="overriddenPropertyName">Имя виртуального свойства</param>
            <param name="newPropertyName">Имя теневого свойства</param>
            <returns>Определённое теневое свойство</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.DynamicTypes.PropertyCreator">
            <summary>
            Создаёт свойства в динамических типах
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.PropertyCreator.CreateAutoProperty(System.Reflection.Emit.TypeBuilder,System.Type,System.String)">
            <summary>
            Создать свойство, скрывающее поле
            </summary>
            <param name="type">Тип, в котором создаётся свойство</param>
            <param name="propertyType">Тип свойства</param>
            <param name="propertyName">Имя свойства</param>
            <returns>Построенное свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.PropertyCreator.MakeWriteableShadow(System.Reflection.Emit.TypeBuilder,System.Type,System.String,System.String)">
            <summary>
            Переопределить геттер виртуального свойства (без сеттера), выдавая из него значение другого свойства с сеттером
            </summary>
            <param name="type">Строящийся тип</param>
            <param name="propertyType">Тип свойства</param>
            <param name="overriddenPropertyName">Имя виртуального свойства</param>
            <param name="newPropertyName">Имя теневого свойства</param>
            <returns>Определённое теневое свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.DynamicTypes.PropertyCreator.DefineProperty(System.Reflection.Emit.TypeBuilder,System.Type,System.String)">
            <summary>
            Определить свойство в типе (например, в интерфейсе)
            </summary>
            <param name="type">Тип</param>
            <param name="propertyType">Тип свойства</param>
            <param name="propertyName">Имя свойства</param>
            <returns>Определённое свойство</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Exceptions.InnerExpressionException">
            <summary>
            Исключение внутри выражения маппинга
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Exceptions.InnerExpressionException.ErrorExpression">
            <summary>
            Выражение, в котором возникло исключение
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Exceptions.InnerExpressionException.Message">
            <summary>
            Сообщение
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Exceptions.InnerExpressionException.#ctor(System.Linq.Expressions.Expression,System.String,System.Exception)">
            <summary>
            Исключение внутри выражения маппинга
            </summary>
            <param name="errorExpression">Выражение, внутри которого возникло исключение</param>
            <param name="message">Сообщение</param>
            <param name="innerException">Исключение</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Exceptions.InvalidPathException">
            <summary>
            Неверное выражение пути
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Exceptions.InvalidPathException.#ctor(System.String)">
            <summary>
            Неверное выражение пути
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Exceptions.UnableToBuildActionException">
            <summary>
            Исключение, возникающее при невозможности построить обновляющий делегат
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Exceptions.UnableToBuildActionException.InvalidType">
            <summary>
            Тип внутреннего объекта, который не удалось создать
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Exceptions.UnableToBuildActionException.IsCollectionElement">
            <summary>
            Создавался ли объект внутри вложенной коллекции или как отдельный вложенный объект
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Exceptions.UnableToBuildActionException.IsKnown">
            <summary>
            Удалось ли установить тип объекта через <see cref="T:TsSoft.Expressions.Models.Reflection.IObjectUpdateManager"/>
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Exceptions.UnableToBuildActionException.#ctor(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Исключение, возникающее при невозможности создания внутреннего объекта для обновления контейнера
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.ExpressionBuilder">
            <summary>
            Построитель выражений
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper,TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary)">
            <summary>
            Построитель выражений
            </summary>
            <param name="memberInfoHelper">Хелпер для извлечения методов</param>
            <param name="memberInfoLibrary">Библиотека методов</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildIncludeByPath``1(System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Построить выражение по линейному пути
            </summary>
            <typeparam name="TEntity">Тип входа</typeparam>
            <param name="properties">Линейный путь</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildIncludeByPath(System.Type,System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Построить выражение по линейному пути
            </summary>
            <param name="paramType">Тип входа</param>
            <param name="properties">Линейный путь</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildPathWithNullChecks(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember},System.Boolean)">
            <summary>
            Построить по списку свойств (A, B, C, D) выражение x?.A?.Select(a => a?.B)?.SelectMany(b => b?.C)?.Select(c => c?.D);
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildPathWithNullChecks(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.Path.PathElement},System.Boolean)">
            <summary>
            Построить по списку свойств (A, B, C, D) выражение x?.A?.Select(a => a?.B)?.SelectMany(b => b?.C)?.Select(c => c?.D);
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildPathWithNullChecks(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.Path.PathElement},System.Boolean,System.Type)">
            <summary>
            Построить по списку свойств (A, B, C, D) выражение x?.A?.Select(a => a?.B)?.SelectMany(b => b?.C)?.Select(c => c?.D);
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildPropertyExpression(System.Reflection.PropertyInfo)">
            <summary>
            Построить выражение обращения к свойству o => o.Property
            </summary>
            <param name="property">Свойство</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildMemberAccessExpression(TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Построить выражение обращения к члену o => o.Property
            </summary>
            <param name="member">Член</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildMemberAccessExpression(System.Type,TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Построить выражение обращения к члену o => o.Property
            </summary>
            <param name="parameterType">Тип параметра</param>
            <param name="member">Член</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildPropertyExpression(System.Type,System.String)">
            <summary>
            Построить выражение обращения к свойству o => o.Property
            </summary>
            <param name="declaringType">Тип параметра</param>
            <param name="propertyName">Имя свойства</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereContains``1(System.Reflection.PropertyInfo,System.String)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="property">Свойство</param>
            <param name="pattern">Искомая строка</param>
            <returns>e => e.Property.ToString().Contains(pattern)</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereContains``1(System.String,System.String)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="propertyName">Имя свойства</param>
            <param name="pattern">Искомая строка</param>
            <returns>e => e.Property.ToString().Contains(pattern)</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereAnyContains``1(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo},System.String)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="properties">Свойства</param>
            <param name="pattern">Искомая строка</param>
            <returns>e => e.Property[0].ToString().Contains(pattern) || e.Property[1].ToString().Contains(pattern) || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereAnyContains``1(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="properties">Имена свойств</param>
            <param name="pattern">Искомая строка</param>
            <returns>e => e.Property[0].ToString().Contains(pattern) || e.Property[1].ToString().Contains(pattern) || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereEquals``2(System.Reflection.PropertyInfo,``1)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TProperty">Тип свойства</typeparam>
            <param name="property">Свойство</param>
            <param name="value">Значение</param>
            <returns>e => e.Property == value</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereEquals``2(System.String,``1)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TProperty">Тип свойства</typeparam>
            <param name="propertyName">Имя свойства</param>
            <param name="value">Значение</param>
            <returns>e => e.Property == value</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereEquals``1(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="property">Свойство</param>
            <param name="value">Значение</param>
            <returns>e => e.Property == value</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereEquals``1(System.String,System.Object)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="propertyName">Имя свойства</param>
            <param name="value">Значение</param>
            <returns>e => e.Property == value</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereEquals``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Reflection.PropertyInfo,System.Object}})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="values">Свойства и их значения</param>
            <returns>e => e.Property1 == value1 and e.Property2 == value2 and ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereEquals``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="values">Имена и значения свойств</param>
            <returns>e => e.Property1 == value1 and e.Property2 == value2 and ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereIn``1(System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="property">Свойство</param>
            <param name="values">Значения</param>
            <returns>e => e.Property == value1 || e.Property == value2 || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereIn``2(System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
            <param name="property">Свойство</param>
            <param name="values">Значения</param>
            <returns>e => e.Property == value1 || e.Property == value2 || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildWhereIn``2(TsSoft.Expressions.Models.ValueHoldingMember,System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
            <param name="property">Свойство</param>
            <param name="values">Значения</param>
            <returns>e => e.Property == value1 || e.Property == value2 || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.For(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
            <summary>
            Построить выражение для for-цикла
            </summary>
            <param name="init">Инициализация перед циклом</param>
            <param name="check">Условие выполнения шага</param>
            <param name="step">Перход к следующему шагу</param>
            <param name="body">Тело</param>
            <param name="variables">Переменные цикла</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.ForRange(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Построить выражение для for-цикла с одной целочисленной переменной
            </summary>
            <param name="variable">Переменная цикла</param>
            <param name="first">Первое значение</param>
            <param name="afterLast">Значение, следующее за последним</param>
            <param name="body">Тело</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.Foreach``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Построить выражение для foreach-цикла
            </summary>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <param name="collection">Коллекция, по которой проходит цикл</param>
            <param name="current">Параметр цикла</param>
            <param name="body">Тело цикла</param>
            <returns>Выражение для цикла</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.Foreach(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Построить выражение для foreach-цикла
            </summary>
            <param name="collection">Коллекция, по которой проходит цикл</param>
            <param name="current">Параметр цикла</param>
            <param name="body">Тело цикла</param>
            <param name="elementType">Тип элемента коллекции</param>
            <returns>Выражение для цикла</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.WhereNotNull(System.Linq.Expressions.Expression)">
            <summary>
            Отфильтровать null-элементы из выражения-коллекции
            </summary>
            <param name="collection">Выражение-коллекция</param>
            <returns>coll.Where(x => x != null)</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildPreconditionExpression(TsSoft.Expressions.Models.Path.ParsedPath,System.Boolean)">
            <summary>
            Построить условие того, что проход по пути не выбросит <see cref="T:System.NullReferenceException"/>
            </summary>
            <param name="path">Путь</param>
            <param name="checkPathResult">Проверить также результат прохода по пути</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionBuilder.BuildPathLeadsToNullExpression(TsSoft.Expressions.Models.Path.ParsedPath,System.Boolean)">
            <summary>
            Построить условие того, что на пути встречается null
            </summary>
            <param name="path">Путь</param>
            <param name="checkPathResult">Проверить также результат прохода по пути</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.ExpressionDifference">
            <summary>
            Различие в выражениях
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.ExpressionDifference.First">
            <summary>
            Первое подвыражение, в котором найдено различие
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.ExpressionDifference.Second">
            <summary>
            Второе подвыражение, в котором найдено различие
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.ExpressionDifference.Reason">
            <summary>
            Описание различия
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionDifference.#ctor(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.String)">
            <summary>
            Различие в выражениях
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionDifference.ToString">
            <summary>
            Строковое представление
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.SpecificExpressionDifference`1">
            <summary>
            Различие в выражениях
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.SpecificExpressionDifference`1.FirstElement">
            <summary>
            Отличающийся элемент первого выражения
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.SpecificExpressionDifference`1.SecondElement">
            <summary>
            Отличающийся элемент второго выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.SpecificExpressionDifference`1.#ctor(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,`0,`0,System.String)">
            <summary>
            Различие в выражениях
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.SpecificExpressionDifference`1.ToString">
            <summary>
            Строковое представление
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.SpecificExpressionDifferenceWithMatch`1">
            <summary>
            Различие в выражениях
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.SpecificExpressionDifferenceWithMatch`1.Match">
            <summary>
            Элемент, соответствующий элементу первого выражения во втором выражении
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.SpecificExpressionDifferenceWithMatch`1.#ctor(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,`0,`0,`0,System.String)">
            <summary>
            Различие в выражениях
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.SpecificExpressionDifferenceWithMatch`1.ToString">
            <summary>
            Строковое представление
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.ExpressionEqualityComparer">
            <summary>
            Проверяет на равенство выражения
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Instance">
            <summary>
            Сравнивает выражения с точностью до имён параметров и меток
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.ClosureAwareInstance">
            <summary>
            Сравнивает выражения с точностью до имён параметров и меток, вычисляя значения констант в замыканиях
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.ConstantComputingInstance">
            <summary>
            Сравнивает выражения с точностью до имён параметров и меток, вычисляя значения констант в выражениях MemberAccess
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.TypeUnawareInstance">
            <summary>
            Сравнивает выражения с точностью до имён параметров и меток, одноимённые свойства разных типов считаются эквивалентными
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.TypeUnawareIgnoreOrderInstance">
            <summary>
            Сравнивает выражения с точностью до имён параметров и меток, одноимённые свойства разных типов считаются эквивалентными, порядок следования биндингов не учитывается
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Проверяет на равенство выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Equals(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Equals(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression)">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.GetHashCode(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Хэш выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Equals``1(System.Linq.Expressions.Expression{``0},System.Linq.Expressions.Expression{``0})">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.GetHashCode(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ElementInit})">
            <summary>
            Хэш набора инициализаторов коллекции
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.GetHashCode(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
            <summary>
            Хэш набора инициализаторов объекта
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.GetHashCode(System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
            <summary>
            Хэш набора блоков оператора switch
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.GetHashCode(System.Reflection.MemberInfo)">
            <summary>
            Хэш члена класса
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.GetHashCode(System.Linq.Expressions.CatchBlock)">
            <summary>
            Хэш набора инициализаторов коллекции
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.GetHashCode(System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
            <summary>
            Хэш набора блоков catch
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.GetHashCode(System.Linq.Expressions.Expression)">
            <summary>
            Получить хэш выражения
            </summary>
            <param name="obj">Выражение</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Reflection.MemberInfo,System.Reflection.MemberInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли члены класса
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.Expression},System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context,TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли списки выражений
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ElementInit},System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ElementInit},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context,TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли списки инициализаторов коллекций
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.MemberBinding},System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.MemberBinding},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context,TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли списки инициализаторов объекта
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqualAndMap(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IDictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IDictionary{System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget},TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли списки параметров, обновить маппинг параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqualAndMap(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Collections.Generic.IDictionary{System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget},TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли метки, обновить маппинг меток
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IDictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли параметры
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IDictionary{System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget},TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли метки
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.SwitchCase},System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context,TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли списки блоков оператора switch
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.CatchBlock},System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context,TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли списки блоков catch
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IDictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IDictionary{System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget})">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="parameterMap">Сопоставление параметров</param>
            <param name="labelMap">Сопоставление меток</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="diff">Найденное различие</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IDictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IDictionary{System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget},TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="parameterMap">Сопоставление параметров</param>
            <param name="labelMap">Сопоставление меток</param>
            <param name="diff">Найденное различие</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.Stack{System.Collections.Generic.IDictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression}},System.Collections.Generic.IDictionary{System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget})">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="parameterMap">Сопоставление параметров</param>
            <param name="labelMap">Сопоставление меток</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context)">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="context">Контекст сравнения</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.AreEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context,TsSoft.Expressions.Helpers.ExpressionDifference@)">
            <summary>
            Равны ли выражения
            </summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="context">Контекст сравнения</param>
            <param name="diff">Найденное различие</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context">
            <summary>
            Контекст сравнения
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.ParameterMap">
            <summary>
            Сопоставление параметров
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.LabelMap">
            <summary>
            Сопоставление меток
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.ConstantComparer">
            <summary>
            Сравнитель констант
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.Depth">
            <summary>
            Текущая глубина стека вызовов
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.MaxDepth">
            <summary>
            Максимально допустимая глубина стека вызовов
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.SingleComparer">
            <summary>
            Сравнитель констант по умолчанию - полагается на object.Equals
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.CollectionElementComparer">
            <summary>
            Сравнитель констант, сравнивающий объекты, реализующие IEnumerable, поэлементно
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.#ctor(System.Collections.Generic.IDictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IDictionary{System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget})">
            <summary>Создать контекст сравнения</summary>
            <param name="parameterMap">Сопоставление параметров</param>
            <param name="labelMap">Сопоставление меток</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.ExpressionEqualityComparer.Context.#ctor(System.Collections.Generic.Stack{System.Collections.Generic.IDictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression}},System.Collections.Generic.IDictionary{System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget})">
            <summary>Создать контекст сравнения</summary>
            <param name="parameterMap">Сопоставление параметров</param>
            <param name="labelMap">Сопоставление меток</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Extensions.DelegateCreator">
            <summary>
            Создаёт делегаты
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.DelegateCreator.Create``1(System.Object,System.Reflection.MethodInfo)">
            <summary>
            Создать делегат по объекту и его методу
            </summary>
            <typeparam name="T">Тип делегата</typeparam>
            <param name="firstArgument">this</param>
            <param name="method">Метод</param>
            <returns>Делегат</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions">
            <summary>
            Расширения перечислений
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions.ToReadOnlyCollectionIfNeeded``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Привести перечисление к IReadOnlyCollection, материализовав его при необходимости
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions.ToReadOnlyListIfNeeded``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Привести перечисление к IReadOnlyList, материализовав его при необходимости
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions.ToArrayIfNeeded``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Привести перечисление к массиву, преобразовав его при необходимости
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions.NotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Заменить null на пустое перечисление
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions.ArrayBatch``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Разбить перечисление на перечисление массивов фиксированного размера
            </summary>
            <typeparam name="T">Тип перечисляемого объекта</typeparam>
            <param name="source">Перечисление</param>
            <param name="size">Размер массивов</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions.AfterEnumeration``1(System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary>
            Выполнить действие после перебора всех элементов перечисления
            </summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="enumerable">Перечисление</param>
            <param name="action">Действие</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions.AppendOne``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Добавить элемент в перечисление
            </summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="enumerable">Перечисление</param>
            <param name="value">Добавляемый элемент</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumerableExtensions.FirstIfSingleOtherwiseDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Возвращает первое значение перечисления, если оно единственное, default(T) в противном случае
            </summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="enumerable">Перечисление</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Extensions.EnumeratorExtensions">
            <summary>
            Расширения для IEnumerator
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumeratorExtensions.ToList``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Создать List из IEnumerator-а (без текущего элемента, если сдвиг уже произошёл)
            </summary>
            <typeparam name="T">Тип элемента перечисления</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumeratorExtensions.ToReadOnlyCollection``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Создать IReadOnlyCollection из IEnumerator-а (без текущего элемента, если сдвиг уже произошёл)
            </summary>
            <typeparam name="T">Тип элемента перечисления</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumeratorExtensions.ToListWithCurrent``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Создать List из IEnumerator-а (вместе с текущим элементом)
            </summary>
            <typeparam name="T">Тип элемента перечисления</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.EnumeratorExtensions.ToReadOnlyCollectionWithCurrent``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Создать IReadOnlyCollection из IEnumerator-а (вместе с текущим элементом)
            </summary>
            <typeparam name="T">Тип элемента перечисления</typeparam>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Extensions.ExpressionExtensions">
            <summary>
            Расширения для лямбда-выражений
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.ExpressionExtensions.ParameterAt(System.Linq.Expressions.LambdaExpression,System.Int32)">
            <summary>
            Получить параметр по индексу
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.ExpressionExtensions.LambdaArgument(System.Linq.Expressions.MethodCallExpression,System.Int32)">
            <summary>
            Получить аргумент метода, являющийся лямбда-выражением
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Extensions.IlGeneratorExtensions">
            <summary>
            Расширения генератора IL
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.IlGeneratorExtensions.EmitLoadArg(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Загрузить на стек аргумент
            </summary>
            <param name="generator">Генератор</param>
            <param name="argIndex">Номер аргумента</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Extensions.ObjectExtensions">
            <summary>
            Расширения для произвольных типов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.ObjectExtensions.ToEnumerable``1(``0)">
            <summary>
            Сделать перечисление из одного элемента
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="obj">Элемент</param>
            <returns>Перечисление</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.ObjectExtensions.ConcatWith``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Сделать перечисление из объекта и перечисления
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="obj">Объект</param>
            <param name="enumerable">Перечисление</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.ObjectExtensions.ToEnumerableNotNull``1(``0)">
            <summary>
            Сделать перечисление из одного элемента, если он не null, и пустое перечисление в противном случае
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="obj">Элемент</param>
            <returns>Перечисление</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.ObjectExtensions.As``1(System.Object)">
            <summary>
            Привести объект к типу T, в случае неудачи отдать default(T)
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Extensions.NullityHelpers.ObjectExtensions">
            <summary>
            Расширения для произвольных типов, связанные с null
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.NullityHelpers.ObjectExtensions.ThrowIfNull``1(``0,System.String)">
            <summary>
            Выбросить исключение <see cref="T:System.NullReferenceException"/> при передаче null
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Объект</param>
            <param name="objName">Имя объекта для формирования сообщения в исключении</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.NullityHelpers.ObjectExtensions.ThrowIfNull``1(``0,System.String,System.Object[])">
            <summary>
            Выбросить исключение <see cref="T:System.NullReferenceException"/> при передаче null
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Объект</param>
            <param name="message">Сообщение</param>
            <param name="param">Параметры сообщения</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Extensions.NullityHelpers.ObjectExtensions.ThrowIfNull``1(``0,System.Object)">
            <summary>
            Выбросить исключение <see cref="T:System.NullReferenceException"/> при передаче null
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Объект</param>
            <param name="generator">Объект, из которого получился null</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.FlatPathParser">
            <summary>
            Выделяет простой путь из выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.FlatPathParser.Parse(System.Linq.Expressions.Expression)">
            <summary>
            Выделить путь (последовательность свойств) из выражения
            </summary>
            <param name="pathExpression">Выражение</param>
            <returns>Путь</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IConvertRemover">
            <summary>
            Удаляет элементы Convert из выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IConvertRemover.RemoveInterfaceCast``1(``0)">
            <summary>
            Удалить Convert к интерфейсам из выражения
            </summary>
            <typeparam name="TExpression">Тип выражения</typeparam>
            <param name="expression">Выражение</param>
            <returns>Преобразованное выражение</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IExceptionWrapperHelper">
            <summary>
            Построитель выражения для ловли и оборачивания исключений
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExceptionWrapperHelper.Wrap(System.Linq.Expressions.Expression,System.Type,System.String)">
            <summary>
            Построить выражение, ловящее и оборачивающее исключение
            </summary>
            <param name="inner">Исходное выражение</param>
            <param name="caughtExceptionType">Тип отлавливаемых исключений</param>
            <param name="message">Сообщение исключения-обёртки</param>
            <returns>Обёрнутое выражение</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IExpressionBuilder">
            <summary>
            Построитель выражений
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildIncludeByPath``1(System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Построить инклюд-выражение по линейному пути (используется Enumerable.Select, не используется Enumerable.SelectMany, результат может иметь тип IEnumerable{IEnumerable{...}})
            </summary>
            <typeparam name="TEntity">Тип входа</typeparam>
            <param name="properties">Линейный путь</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildIncludeByPath(System.Type,System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Построить инклюд-выражение по линейному пути (используется Enumerable.Select, не используется Enumerable.SelectMany, результат может иметь тип IEnumerable{IEnumerable{...}})
            </summary>
            <param name="paramType">Тип входа</param>
            <param name="properties">Линейный путь</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildPropertyExpression(System.Reflection.PropertyInfo)">
            <summary>
            Построить выражение обращения к свойству o => o.Property
            </summary>
            <param name="property">Свойство</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildMemberAccessExpression(TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Построить выражение обращения к члену o => o.Property
            </summary>
            <param name="member">Член</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildMemberAccessExpression(System.Type,TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Построить выражение обращения к члену o => o.Property
            </summary>
            <param name="parameterType">Тип параметра</param>
            <param name="member">Член</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildPropertyExpression(System.Type,System.String)">
            <summary>
            Построить выражение обращения к свойству o => o.Property
            </summary>
            <param name="declaringType">Тип параметра</param>
            <param name="property">Имя свойства</param>
            <returns>Лямбда-выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildPathWithNullChecks(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember},System.Boolean)">
            <summary>
            Построить по списку свойств (A, B, C, D) выражение x?.A?.Select(a => a?.B)?.SelectMany(b => b?.C)?.Select(c => c?.D);
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildPathWithNullChecks(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.Path.PathElement},System.Boolean)">
            <summary>
            Построить по списку свойств (A, B, C, D) выражение x?.A?.Select(a => a?.B)?.SelectMany(b => b?.C)?.Select(c => c?.D);
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildPathWithNullChecks(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.Path.PathElement},System.Boolean,System.Type)">
            <summary>
            Построить по списку свойств (A, B, C, D) выражение x?.A?.Select(a => a?.B)?.SelectMany(b => b?.C)?.Select(c => c?.D);
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereContains``1(System.Reflection.PropertyInfo,System.String)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="property">Свойство</param>
            <param name="pattern">Искомая строка</param>
            <returns>e => e.Property.ToString().Contains(pattern)</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereContains``1(System.String,System.String)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="propertyName">Имя свойства</param>
            <param name="pattern">Искомая строка</param>
            <returns>e => e.Property.ToString().Contains(pattern)</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereAnyContains``1(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo},System.String)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="properties">Свойства</param>
            <param name="pattern">Искомая строка</param>
            <returns>e => e.Property[0].ToString().Contains(pattern) || e.Property[1].ToString().Contains(pattern) || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereAnyContains``1(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="properties">Имена свойств</param>
            <param name="pattern">Искомая строка</param>
            <returns>e => e.Property[0].ToString().Contains(pattern) || e.Property[1].ToString().Contains(pattern) || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereEquals``2(System.Reflection.PropertyInfo,``1)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TProperty">Тип свойства</typeparam>
            <param name="property">Свойство</param>
            <param name="value">Значение</param>
            <returns>e => e.Property == value</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereEquals``2(System.String,``1)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TProperty">Тип свойства</typeparam>
            <param name="propertyName">Имя свойства</param>
            <param name="value">Значение</param>
            <returns>e => e.Property == value</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereEquals``1(System.String,System.Object)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="propertyName">Имя свойства</param>
            <param name="value">Значение</param>
            <returns>e => e.Property == value</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereEquals``1(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="property">Свойство</param>
            <param name="value">Значение</param>
            <returns>e => e.Property == value</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereEquals``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="values">Имена и значения свойств</param>
            <returns>e => e.Property1 == value1 and e.Property2 == value2 and ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereEquals``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Reflection.PropertyInfo,System.Object}})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="values">Свойства и их значения</param>
            <returns>e => e.Property1 == value1 and e.Property2 == value2 and ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereIn``1(System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <param name="property">Свойство</param>
            <param name="values">Значения</param>
            <returns>e => e.Property == value1 || e.Property == value2 || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildWhereIn``2(System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
            <param name="property">Свойство</param>
            <param name="values">Значения</param>
            <returns>e => e.Property == value1 || e.Property == value2 || ...</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.For(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
            <summary>
            Построить выражение для for-цикла
            </summary>
            <param name="init">Инициализация перед циклом</param>
            <param name="check">Условие выполнения шага</param>
            <param name="step">Перход к следующему шагу</param>
            <param name="body">Тело</param>
            <param name="variables">Переменные цикла</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.ForRange(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Построить выражение для for-цикла с одной целочисленной переменной
            </summary>
            <param name="variable">Переменная цикла</param>
            <param name="first">Первое значение</param>
            <param name="afterLast">Значение, следующее за последним</param>
            <param name="body">Тело</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.Foreach``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Построить выражение для foreach-цикла
            </summary>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <param name="collection">Коллекция, по которой проходит цикл</param>
            <param name="current">Параметр цикла</param>
            <param name="body">Тело цикла</param>
            <returns>Выражение для цикла</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.Foreach(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Построить выражение для foreach-цикла
            </summary>
            <param name="collection">Коллекция, по которой проходит цикл</param>
            <param name="current">Параметр цикла</param>
            <param name="body">Тело цикла</param>
            <param name="elementType">Тип элемента коллекции</param>
            <returns>Выражение для цикла</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.WhereNotNull(System.Linq.Expressions.Expression)">
            <summary>
            Отфильтровать null-элементы из выражения-коллекции
            </summary>
            <param name="collection">Выражение-коллекция</param>
            <returns>coll.Where(x => x != null)</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildPreconditionExpression(TsSoft.Expressions.Models.Path.ParsedPath,System.Boolean)">
            <summary>
            Построить условие того, что проход по пути не выбросит <see cref="T:System.NullReferenceException"/>
            </summary>
            <param name="path">Путь</param>
            <param name="checkPathResult">Проверить также результат прохода по пути</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionBuilder.BuildPathLeadsToNullExpression(TsSoft.Expressions.Models.Path.ParsedPath,System.Boolean)">
            <summary>
            Построить условие того, что на пути встречается null
            </summary>
            <param name="path">Путь</param>
            <param name="checkPathResult">Проверить также результат прохода по пути</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IExpressionCompositionHelper">
            <summary>
            Хелпер для сборки выражений из частей
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionCompositionHelper.Compose``3(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
            Собрать выражение-композицию: f, g -> f(g)
            </summary>
            <typeparam name="TOuterParameter">Тип параметра внутренней лямбды</typeparam>
            <typeparam name="TInnerParameter">Тип выхода внутренней лямбды и тип параметра внешней лямбды</typeparam>
            <typeparam name="TReturn">Тип выхода внешней лямбды</typeparam>
            <param name="innerLambda">Внутренняя лямбда</param>
            <param name="outerLambda">Внешняя лямбда</param>
            <returns>Лямбда-композиция</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionCompositionHelper.ComposeWithSelect``2(System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,System.Object}})">
            <summary>
            Собрать выражение-композицию через Select: f, g -> g().Select(f)
            </summary>
            <typeparam name="TOuterParameter">Тип параметра внутренней лямбды</typeparam>
            <typeparam name="TInnerParameter">Тип элемента коллекции-выхода внутренней лямбды и тип параметра внешней лямбды</typeparam>
            <param name="outerLambda">Внешяя лямбда</param>
            <param name="innerLambda">Внутренняя лямбда</param>
            <returns>Лямбда-композиция</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionCompositionHelper.ReplaceInterfaceWithImplementation``2(System.Linq.Expressions.Expression{System.Func{``1,System.Object}})">
            <summary>
            Заменить тип параметра
            </summary>
            <typeparam name="TParameter">Желаемый тип параметра</typeparam>
            <typeparam name="TParameterInterface">Исходный тип параметра</typeparam>
            <param name="lambda">Лямбда</param>
            <returns>Лямбда с изменённым типом параметра</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IExpressionCompositionHelper.MakeObjectOutput``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Заменить тип выхода на object
            </summary>
            <typeparam name="TParameter">Тип параметра</typeparam>
            <typeparam name="TOutput">Исходный тип выхода</typeparam>
            <param name="lambda">Лямбда</param>
            <returns>Лямбда с типом выхода object</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IFlatPathParser">
            <summary>
            Выделяет простой путь из выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IFlatPathParser.Parse(System.Linq.Expressions.Expression)">
            <summary>
            Выделить путь (последовательность свойств) из выражения
            </summary>
            <param name="pathExpression">Выражение</param>
            <returns>Путь</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IKeyExpressionBuilder">
            <summary>
            Построитель выражений с ключами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IKeyExpressionBuilder.GetKeyType(System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Получить тип ключа, который можно выделить
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IKeyExpressionBuilder.GetKeyType(System.Collections.Generic.IReadOnlyList{System.Reflection.PropertyInfo})">
            <summary>
            Получить тип ключа, который можно выделить
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IKeyExpressionBuilder.CreateExtractKeyExpression(System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember},System.Boolean)">
            <summary>
            Создать выделитель ключа из объекта
            </summary>
            <param name="obj">Объект</param>
            <param name="key">Ключ</param>
            <param name="replaceNullsWithDefaults">Заменить nullable-типы на не-nullable, подставляя значение по умолчанию вместо null</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IKeyExpressionBuilder.BuildWhereIn``2(System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TValue">Тип композитного ключа</typeparam>
            <param name="key">Ключ</param>
            <param name="values">Значения</param>
            <returns>e => (e.Property1 == values1.Item1 AND e.Property2 = values1.Item2) || (e.Property1 == values2.Item1 AND e.Property2 = values2.Item2) || ...</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IncludeEqualityComparer`1">
            <summary>
            Проверяет на равенство выражения-пути
            </summary>
            <typeparam name="TEntity">Тип начала пути</typeparam>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.IncludeEqualityComparer`1.Instance">
            <summary>
            Проверяет на равенство выражения-пути
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IncludeEqualityComparer`1.Equals(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Равны ли пути
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IncludeEqualityComparer`1.GetHashCode(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Получить хэш пути
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.INewExpressionHelper">
            <summary>
            Обрабатывает выражения присваивания значений свойствам/полям объекта
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.INewExpressionHelper.GetAssignments(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить присваиваемые значения из выражения e => new {...} или e => new X {...}
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.INewExpressionHelper.GetAssignments(System.Linq.Expressions.MemberInitExpression)">
            <summary>
            Получить присваиваемые значения из выражения new X {...}
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.INewExpressionHelper.GetAssignments(System.Linq.Expressions.NewExpression)">
            <summary>
            Получить присваиваемые значения из выражения new X {...}
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.INewExpressionHelper.ParseAssignment(System.Linq.Expressions.MemberAssignment,System.Type)">
            <summary>
            Разобрать выражение присваивания
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.INewExpressionHelper.ParseAssignment(System.Collections.Generic.KeyValuePair{System.Reflection.MemberInfo,System.Linq.Expressions.Expression},System.Type)">
            <summary>
            Разобрать выражение присваивания
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.INewExpressionHelper.ComposeAssignment(System.Collections.Generic.KeyValuePair{System.Reflection.MemberInfo,System.Linq.Expressions.Expression},System.Type)">
            <summary>
            Создать выражение присваивания
            </summary>
            <param name="assignment">Присваивание как пара (свойство, значение)</param>
            <param name="destinationType">Тип, свойству которого присваивается значение</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.INewExpressionHelper.DecomposeAssignment(System.Linq.Expressions.MemberAssignment)">
            <summary>
            Разобрать выражение присваивания на пару (свойство, значение)
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IPathBuilder">
            <summary>
            Преобразует путь в лямбду
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPathBuilder.Build(System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Преобразовать разобранный плоский путь в лямбду
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPathBuilder.Build(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})">
            <summary>
            Преобразовать разобранный плоский путь в лямбду
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPathBuilder.Build(TsSoft.Expressions.Models.Path.ParsedPath)">
            <summary>
            Преобразовать разобранный путь в лямбду
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IPathHelper">
            <summary>
            Хелпер для работы с путями
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPathHelper.GetPathSingleType(System.Type,System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Получить тип выхода пути (или тип элемента коллекции выхода пути, если выход - коллекция)
            </summary>
            <param name="startType">Тип входа пути</param>
            <param name="path">Путь</param>
            <returns>Тип выхода</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPathHelper.GetPathSingleType(System.Type,System.Collections.Generic.IReadOnlyList{System.Reflection.PropertyInfo})">
            <summary>
            Получить тип выхода пути (или тип элемента коллекции выхода пути, если выход - коллекция)
            </summary>
            <param name="startType">Тип входа пути</param>
            <param name="path">Путь</param>
            <returns>Тип выхода</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPathHelper.GetPathSingleType(TsSoft.Expressions.Models.Path.ParsedPath)">
            <summary>
            Получить тип выхода пути (или тип элемента коллекции выхода пути, если выход - коллекция)
            </summary>
            <param name="path">Путь</param>
            <returns>Тип выхода</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IPathParser">
            <summary>
            Выделяет путь из выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPathParser.Parse(System.Linq.Expressions.Expression)">
            <summary>
            Выделить использованный выражением путь
            </summary>
            <param name="expression">Выражение</param>
            <returns>Использованный путь</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IPredicateBuilder`1">
            <summary>
            Билдер предикатов
            </summary>
            <typeparam name="T">Тип параметра</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPredicateBuilder`1.Or(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Добавить выражение через ИЛИ
            </summary>
            <param name="expr">Выражение</param>
            <returns>Билдер</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPredicateBuilder`1.And(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Добавить выражение через И
            </summary>
            <param name="expr">Выражение</param>
            <returns>Билдер</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IPredicateBuilder`1.BuildPredicate">
            <summary>
            Создать предикат
            </summary>
            <returns>Выражение предикат</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.IUpdateObjectActionFactory">
            <summary>
            Фабрика обновляющих объекты функций
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IUpdateObjectActionFactory.MakeUpdateAction``1(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{``0,System.Object}}},TsSoft.Expressions.Models.Reflection.IObjectUpdateManager,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{``0,System.Object}}})">
            <summary>
            Построить обновляющую функцию
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="paths">Обновляемые пути</param>
            <param name="manager">Определитель типа свойства (примитивное, объект или коллекция)</param>
            <param name="dropCreateOnPaths">На каких путях производить перезапись коллекции вместо поэлементного обновления</param>
            <returns>Обновляющая функция</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.IUpdateObjectActionFactory.MakeAsyncUpdateAction``1(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{``0,System.Object}}},TsSoft.Expressions.Models.Reflection.IObjectUpdateManager,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{``0,System.Object}}})">
            <summary>
            Построить асинхронную обновляющую функцию
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="paths">Обновляемые пути</param>
            <param name="manager">Определитель типа свойства (примитивное, объект или коллекция)</param>
            <param name="dropCreateOnPaths">На каких путях производить перезапись коллекции вместо поэлементного обновления</param>
            <returns>Функция, обновляющая объект и возвращающая набор производителей дополнительных задач</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.KeyExpressionBuilder">
            <summary>
            Построитель выражений с ключами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.KeyExpressionBuilder.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper,TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary)">
            <summary>
            Построитель выражений с ключами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.KeyExpressionBuilder.GetKeyType(System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Получить тип ключа, который можно выделить
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.KeyExpressionBuilder.GetKeyType(System.Collections.Generic.IReadOnlyList{System.Reflection.PropertyInfo})">
            <summary>
            Получить тип ключа, который можно выделить
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.KeyExpressionBuilder.CreateExtractKeyExpression(System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember},System.Boolean)">
            <summary>
            Создать выделитель ключа из объекта
            </summary>
            <param name="obj">Объект</param>
            <param name="key">Ключ</param>
            <param name="replaceNullsWithDefaults">Заменить nullable-типы на не-nullable, подставляя значение по умолчанию вместо null</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.KeyExpressionBuilder.BuildWhereIn``2(System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Построить выражение-фильтр
            </summary>
            <typeparam name="TEntity">Тип параметра</typeparam>
            <typeparam name="TValue">Тип композитного ключа</typeparam>
            <param name="key">Ключ</param>
            <param name="values">Значения</param>
            <returns>e => (e.Property1 == values1.Item1 AND e.Property2 = values1.Item2) || (e.Property1 == values2.Item1 AND e.Property2 = values2.Item2) || ...</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.LazyConcurrentDictionary`2">
            <summary>
            Словарь с возможностью одновременного доступа, выполняющий передаваемые в обновляющие методы делегаты не более одного раза
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.LazyConcurrentDictionary`2.LazyGetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Получить имеющееся или добавить значение
            </summary>
            <param name="key">Ключ</param>
            <param name="factory">Делегат создания значения, выполняется не более одного раза</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.LazyConcurrentDictionary`2.LazyAddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
            <summary>
            Обновить имеющееся или добавить значение
            </summary>
            <param name="key">Ключ</param>
            <param name="value">Добавляемое значение</param>
            <param name="updateFactory">Делегат обновления значения, выполняется не более одного раза</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.LazyConcurrentDictionary`2.LazyAddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
            Обновить имеющееся или добавить значение
            </summary>
            <param name="key">Ключ</param>
            <param name="addFactory">Делегат создания значения, выполняется не более одного раза</param>
            <param name="updateFactory">Делегат обновления значения, выполняется не более одного раза</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.MemberInfoNameComparer">
            <summary>
            Проверяет на равенство MemberInfo, сравнивая только имена
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.MemberInfoNameComparer.Instance">
            <summary>
            Проверяет на равенство MemberInfo, сравнивая только имена
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.MemberInfoNameComparer.Equals(System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
            <summary>
            Равны ли имена свойств
            </summary>
            <returns></returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.MemberInfoNameComparer.GetHashCode(System.Reflection.PropertyInfo)">
            <summary>
            Получить хэш имени свойства
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.MemberInfoNameComparer.Equals(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
            <summary>
            Равны ли имена членов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.MemberInfoNameComparer.GetHashCode(System.Reflection.MemberInfo)">
            <summary>
            Получить хэш имени члена
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.MemberInfoNameComparer.Equals(TsSoft.Expressions.Models.ValueHoldingMember,TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Равны ли имена членов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.MemberInfoNameComparer.GetHashCode(TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Получить хэш имени члена
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.NestedGenerators.INestedGeneratorHelper">
            <summary>
            Хелпер для построения объектов в контексте
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.NestedGenerators.INestedGeneratorHelper.GenerateInContext``4(``2,System.Func{``2,``1},System.Func{``2,``3,``1},System.Func{``1,``0},``3,``0)">
            <summary>
            Построить объект в контексте
            </summary>
            <typeparam name="T">Тип объекта для построения</typeparam>
            <typeparam name="TGenerator">Тип генератора</typeparam>
            <typeparam name="TContext">Тип контекста</typeparam>
            <typeparam name="TRaw">Тип сырого объекта, отдаваемого генератором</typeparam>
            <param name="generator">Генератор</param>
            <param name="generationWithoutContextFunc">Делегат для получения уже сгенерированного объекта</param>
            <param name="generationFunc">Делегат для генерации объекта в контексте</param>
            <param name="processor">Обработчик сырого объекта</param>
            <param name="context">Контекст</param>
            <param name="onExhaustedNesting">Объект, возвращаемый при исчерпанной вложенности</param>
            <returns>Построенный объект</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.PathBuilder">
            <summary>
            Преобразует путь в лямбду
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PathBuilder.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary)">
            <summary>
            Преобразует путь в лямбду
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PathBuilder.Build(System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Преобразовать разобранный плоский путь в лямбду
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PathBuilder.Build(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})">
            <summary>
            Преобразовать разобранный плоский путь в лямбду
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PathBuilder.Build(TsSoft.Expressions.Models.Path.ParsedPath)">
            <summary>
            Преобразовать разобранный путь в лямбду
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.PredicateBuilder">
            <summary>
            Построитель предикатов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PredicateBuilder.True``1">
            <summary>
            Предикат ИСТИНА
            </summary>
            <typeparam name="T">Тип параметра</typeparam>
            <returns>Всегда истинный предикат</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PredicateBuilder.False``1">
            <summary>
            Предикат ЛОЖЬ
            </summary>
            <typeparam name="T">Тип параметра</typeparam>
            <returns>Всегда ложный предикат</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PredicateBuilder.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Объединить предикаты с помощью оператора ИЛИ
            </summary>
            <typeparam name="T">Тип параметра</typeparam>
            <param name="expr1">Первый предикат</param>
            <param name="expr2">Второй предикат</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PredicateBuilder.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Объединить предикаты с помощью оператора И
            </summary>
            <typeparam name="T">Тип параметра</typeparam>
            <param name="expr1">Первый предикат</param>
            <param name="expr2">Второй предикат</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PredicateBuilder.ToBuilder``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Получить билдер из экспрешена
            </summary>
            <typeparam name="T">Тип параметра</typeparam>
            <param name="expr">Исходный предикат</param>
            <returns>Билдер предикатов</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.PredicateBuilder.Compose``1(System.Linq.Expressions.Expression{``0},System.Linq.Expressions.Expression{``0},System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            Объединить предикаты с помощью оператора
            </summary>
            <typeparam name="T">Тип параметра</typeparam>
            <param name="first">Первый предикат</param>
            <param name="second">Второй предикат</param>
            <param name="merge">Оператор</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.AssemblyTypesRetriever">
            <summary>
            Получает типы из сборки
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.AssemblyTypesRetriever.GetTypes(System.Reflection.Assembly)">
            <summary>
            Получает типы из сборки
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.CollectionReflectionHelper">
            <summary>
            Создаёт коллекции с типами, не известными на момент компиляции
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CollectionReflectionHelper.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper)">
            <summary>
            Создаёт коллекции с типами, не известными на момент компиляции
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CollectionReflectionHelper.MakeList(System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Создать типизированную коллекцию List[T] из нетипизированной
            </summary>
            <param name="listElementType">Тип элемента коллекции</param>
            <param name="objects">Нетипизированная коллекция</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CollectionReflectionHelper.MakeListStrict(System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Создать типизированную коллекцию List[T] из нетипизированной
            </summary>
            <param name="listElementType">Тип элемента коллекции</param>
            <param name="objects">Нетипизированная коллекция</param>
            <exception cref="T:System.InvalidCastException">В исходной коллекции есть элементы, не приводимые к T</exception>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.ConversionChecker">
            <summary>
            Проверяет существование неявных преобразований
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Reflection.ConversionChecker.Instance">
            <summary>
            Экземпляр проверщика существования неявных преобразований
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ConversionChecker.IsImplicitlyConvertible(System.Type,System.Type)">
            <summary>
            Существует ли неявное преобразование (явно определённый метод или соглашение языка c#)
            </summary>
            <param name="source">Тип преобразуемого выражения</param>
            <param name="target">Тип преобразованного выражения</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ConversionChecker.IsConvertible(System.Type,System.Type)">
            <summary>
            Существует ли неявное или явное преобразование (явно определённый метод или соглашение языка c#)
            </summary>
            <param name="source">Тип преобразуемого выражения</param>
            <param name="target">Тип преобразованного выражения</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ConversionChecker.IsPrimitiveImplicitlyConvertible(System.Type,System.Type)">
            <summary>
            Существует ли неявное преобразование типов в языке c#
            </summary>
            <param name="source">Тип преобразуемого выражения</param>
            <param name="target">Тип преобразованного выражения</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ConversionChecker.IsPrimitiveExplicitlyConvertible(System.Type,System.Type)">
            <summary>
            Существует ли преобразование типов в языке c#
            </summary>
            <param name="source">Тип преобразуемого выражения</param>
            <param name="target">Тип преобразованного выражения</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ConversionChecker.IsPrimitiveExplicitlyConvertibleAndNotImplicitlyConvertible(System.Type,System.Type)">
            <summary>
            Существует ли явное преобразование типов в языке c#
            </summary>
            <param name="source">Тип преобразуемого выражения</param>
            <param name="target">Тип преобразованного выражения</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper">
            <summary>
            Хелпер для извлечения соответствующих членов типа
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper.TryGetCorrespondingMember(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Получить одноимённое свойство или поле
            </summary>
            <param name="type">Тип, из которого выделяется свойство или поле</param>
            <param name="propertyOrField">Эталонное свойство или поле</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper.GetCorrespondingMember(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Получить одноимённое свойство или поле
            </summary>
            <param name="type">Тип, из которого выделяется свойство или поле</param>
            <param name="propertyOrField">Эталонное свойство или поле</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper.TryGetCorrespondingMemberForExplicitImplementation(TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Получить свойство, соответствующее свойству, явно реализующему интерфейс
            </summary>
            <param name="explicitProperty">Свойство, явно реализующее интерфейс</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper.TryGetCorrespondingProperty(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Получить одноимённое свойство
            </summary>
            <param name="type">Тип, из которого выделяется свойство или поле</param>
            <param name="propertyOrField">Эталонное свойство или поле</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper.GetImplementation(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Получить реализацию метода
            </summary>
            <param name="impl">Реализующий интерфейс тип</param>
            <param name="interfaceMethod">Метод интерфейса</param>
            <returns>Метод-реализация</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper.GetImplementation(System.Type,System.Reflection.PropertyInfo)">
            <summary>
            Получить реализацию свойства
            </summary>
            <param name="impl">Реализующий интерфейс тип</param>
            <param name="interfaceProperty">Свойство интерфейса</param>
            <returns>Свойство-реализация</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper.GetImplementationIfInterfaceProperty(System.Type,System.Reflection.PropertyInfo)">
            <summary>
            Получить реализацию свойства, если оно определено на интерфейсе, и вернуть исходное свойство в противном случае
            </summary>
            <param name="targetType">Тип, свойство которого требуется получить</param>
            <param name="property">Свойство, возможно, определённое на интерфейсе типа</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.CorrespondingMemberHelper.GetImplementationIfInterfaceProperty(System.Type,TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Получить реализацию свойства, если оно определено на интерфейсе, и вернуть исходное свойство в противном случае
            </summary>
            <param name="targetType">Тип, свойство которого требуется получить</param>
            <param name="member">Свойство, возможно, определённое на интерфейсе типа</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription">
            <summary>
            Описание типа делегата
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription.ParameterTypes">
            <summary>
            Типы параметров
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription.ReturnType">
            <summary>
            Тип возвращаемого значения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription.#ctor(System.Collections.Generic.IEnumerable{System.Type},System.Type)">
            <summary>
            Описание типа делегата
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription.Equals(TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription)">
            <summary>
            Совпадают ли типы параметров и тип возвращаемого значения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription.Equals(System.Object)">
            <summary>
            Совпадают ли типы параметров и тип возвращаемого значения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription.GetHashCode">
            <summary>
            Хэш-код
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.DelegateTypeHelper">
            <summary>
            Обрабатывает типы делегатов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeHelper.CreateDelegateType(System.Reflection.Emit.ModuleBuilder,System.String,TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription)">
            <summary>
            Создать тип делегата
            </summary>
            <param name="moduleBuilder">Модуль</param>
            <param name="typeName">Имя типа</param>
            <param name="description">Описание типа делегата</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeHelper.GetDelegateInvokeMethod(System.Type)">
            <summary>
            Получить метод вызова делегата
            </summary>
            <param name="delegateType">Тип делегата</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeHelper.GetDelegateConstructor(System.Type)">
            <summary>
            Получить конструктор делегата (с параметрами типов <see cref="T:System.Object"/> и <see cref="T:System.IntPtr"/>)
            </summary>
            <param name="delegateType">Тип делегата</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeHelper.GetDelegateDescription(System.Type)">
            <summary>
            Получить описание типа делегата - типы параметров и тип возвращаемого значения
            </summary>
            <param name="delegateType">Тип делегата</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.DelegateTypeHelper.IsDelegateType(System.Type)">
            <summary>
            Является ли тип конкретным типом делегата
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.FlatPathApplicator">
            <summary>
            Применяет путь к объекту
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.FlatPathApplicator.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Применить путь (последовательность свойств) к объектам
            </summary>
            <typeparam name="T">Тип начального объекта</typeparam>
            <param name="objects">Объекты</param>
            <param name="path">Путь</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.IAssemblyTypesRetriever">
            <summary>
            Получает типы из сборки
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IAssemblyTypesRetriever.GetTypes(System.Reflection.Assembly)">
            <summary>
            Получить типы из сборки
            </summary>
            <param name="assembly">Сборка</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.AssemblyTypesRetrieverExtensions">
            <summary>
            Расширения получателя типов из сборки
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.AssemblyTypesRetrieverExtensions.SafeGetTypes(TsSoft.Expressions.Helpers.Reflection.IAssemblyTypesRetriever,System.Reflection.Assembly)">
            <summary>
            Получить типы из сборки
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.ICollectionReflectionHelper">
            <summary>
            Создаёт коллекции с типами, не известными на момент компиляции
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICollectionReflectionHelper.MakeList(System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Создать типизированную коллекцию List[T] из нетипизированной
            </summary>
            <param name="listElementType">Тип элемента коллекции</param>
            <param name="objects">Нетипизированная коллекция</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.IConversionChecker">
            <summary>
            Проверяет существование неявных преобразований
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IConversionChecker.IsImplicitlyConvertible(System.Type,System.Type)">
            <summary>
            Существует ли неявное преобразование (явно определённый метод или соглашение языка c#)
            </summary>
            <param name="source">Тип преобразуемого выражения</param>
            <param name="target">Тип преобразованного выражения</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IConversionChecker.IsPrimitiveImplicitlyConvertible(System.Type,System.Type)">
            <summary>
            Существует ли неявное преобразование типов в языке c#
            </summary>
            <param name="source">Тип преобразуемого выражения</param>
            <param name="target">Тип преобразованного выражения</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper">
            <summary>
            Хелпер для извлечения соответствующих членов типа
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper.TryGetCorrespondingMember(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Получить одноимённое свойство или поле
            </summary>
            <param name="type">Тип, из которого выделяется свойство или поле</param>
            <param name="propertyOrField">Эталонное свойство или поле</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper.TryGetCorrespondingMemberForExplicitImplementation(TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Получить свойство, соответствующее свойству, явно реализующему интерфейс
            </summary>
            <param name="explicitProperty">Свойство, явно реализующее интерфейс</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper.GetCorrespondingMember(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Получить одноимённое свойство или поле
            </summary>
            <param name="type">Тип, из которого выделяется свойство или поле</param>
            <param name="propertyOrField">Эталонное свойство или поле</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper.TryGetCorrespondingProperty(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Получить одноимённое свойство
            </summary>
            <param name="type">Тип, из которого выделяется свойство или поле</param>
            <param name="member">Эталонное свойство или поле</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper.GetImplementation(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Получить реализацию метода
            </summary>
            <param name="impl">Реализующий интерфейс тип</param>
            <param name="interfaceMethod">Метод интерфейса</param>
            <returns>Метод-реализация</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper.GetImplementation(System.Type,System.Reflection.PropertyInfo)">
            <summary>
            Получить реализацию свойства
            </summary>
            <param name="impl">Реализующий интерфейс тип</param>
            <param name="interfaceProperty">Свойство интерфейса</param>
            <returns>Свойство-реализация</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper.GetImplementationIfInterfaceProperty(System.Type,System.Reflection.PropertyInfo)">
            <summary>
            Получить реализацию свойства, если оно определено на интерфейсе, и вернуть исходное свойство в противном случае
            </summary>
            <param name="targetType">Тип, свойство которого требуется получить</param>
            <param name="property">Свойство, возможно, определённое на интерфейсе типа</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ICorrespondingMemberHelper.GetImplementationIfInterfaceProperty(System.Type,TsSoft.Expressions.Models.ValueHoldingMember)">
            <summary>
            Получить реализацию свойства, если оно определено на интерфейсе, и вернуть исходное свойство в противном случае
            </summary>
            <param name="targetType">Тип, свойство которого требуется получить</param>
            <param name="member">Свойство, возможно, определённое на интерфейсе типа</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.IDelegateTypeHelper">
            <summary>
            Обрабатывает типы делегатов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IDelegateTypeHelper.CreateDelegateType(System.Reflection.Emit.ModuleBuilder,System.String,TsSoft.Expressions.Helpers.Reflection.DelegateTypeDescription)">
            <summary>
            Создать тип делегата
            </summary>
            <param name="moduleBuilder">Модуль</param>
            <param name="typeName">Имя типа</param>
            <param name="description">Описание типа делегата</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IDelegateTypeHelper.GetDelegateInvokeMethod(System.Type)">
            <summary>
            Получить метод вызова делегата
            </summary>
            <param name="delegateType">Тип делегата</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IDelegateTypeHelper.GetDelegateConstructor(System.Type)">
            <summary>
            Получить конструктор делегата (с параметрами типов <see cref="T:System.Object"/> и <see cref="T:System.IntPtr"/>)
            </summary>
            <param name="delegateType">Тип делегата</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IDelegateTypeHelper.GetDelegateDescription(System.Type)">
            <summary>
            Получить описание типа делегата - типы параметров и тип возвращаемого значения
            </summary>
            <param name="delegateType">Тип делегата</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IDelegateTypeHelper.IsDelegateType(System.Type)">
            <summary>
            Является ли тип конкретным типом делегата
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.IFlatPathApplicator">
            <summary>
            Применяет путь к объекту
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IFlatPathApplicator.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{TsSoft.Expressions.Models.ValueHoldingMember})">
            <summary>
            Применить путь (последовательность свойств) к объектам
            </summary>
            <typeparam name="T">Тип начального объекта</typeparam>
            <param name="objects">Объекты</param>
            <param name="path">Путь</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper">
            <summary>
            Выделяет члены типов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetMethodInfo(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить метод
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetMethodInfo(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Получить метод
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetMethodInfo``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Получить метод
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetMethodInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить метод
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetGenericDefinitionMethodInfo(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Получить заготовку генерик-метода
            </summary>
            <param name="expression">Выражение - вызов генерик-метода</param>
            <returns>Заготовка метода</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetGenericDefinitionMethodInfo``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Получить заготовку генерик-метода
            </summary>
            <param name="expression">Выражение - вызов генерик-метода</param>
            <returns>Заготовка метода</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetGenericDefinitionMethodInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить заготовку генерик-метода
            </summary>
            <param name="expression">Выражение - вызов генерик-метода</param>
            <returns>Заготовка метода</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetPropertyInfo(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить свойство
            </summary>
            <param name="expression">Выражение - обращение к свойству</param>
            <returns>Свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetPropertyInfo``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Получить свойство
            </summary>
            <param name="expression">Выражение - обращение к свойству</param>
            <returns>Свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetPropertyInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить свойство
            </summary>
            <param name="expression">Выражение - обращение к свойству</param>
            <returns>Свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetFieldInfo(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить поле
            </summary>
            <param name="expression">Выражение - обращение к полю</param>
            <returns>Поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetFieldInfo``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Получить поле
            </summary>
            <param name="expression">Выражение - обращение к полю</param>
            <returns>Поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetFieldInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить поле
            </summary>
            <param name="expression">Выражение - обращение к полю</param>
            <returns>Поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetGenericClassMethod``1(System.Linq.Expressions.Expression{System.Action{``0}},System.Type[])">
            <summary>
            Получить метод генерик-класса
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <param name="genericParameters">Новые параметры для генерик-класса</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetConstructorInfo``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Получить конструктор
            </summary>
            <typeparam name="T">Конструируемый тип</typeparam>
            <param name="expression">Выражение - вызов конструктора</param>
            <returns>Конструктор</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetValueHoldingMember(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить свойство или поле
            </summary>
            <param name="expression">Выражение - обращение к свойству или полю</param>
            <returns>Свойство или поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetValueHoldingMember``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Получить свойство или поле
            </summary>
            <param name="expression">Выражение - обращение к свойству или полю</param>
            <returns>Свойство или поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper.GetValueHoldingMember``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить свойство или поле
            </summary>
            <param name="expression">Выражение - обращение к свойству или полю</param>
            <returns>Свойство или поле</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary">
            <summary>
            Библиотека методов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableSelect(System.Type,System.Type)">
            <summary>
            Enumerable.Select с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableSelectMany(System.Type,System.Type)">
            <summary>
            Enumerable.SelectMany с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableWhere(System.Type)">
            <summary>
            Enumerable.Where
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableToList(System.Type)">
            <summary>
            Enumerable.ToList
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableToArray(System.Type)">
            <summary>
            Enumerable.ToArray
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableSingleOrDefault(System.Type)">
            <summary>
            Enumerable.SingleOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableSingleOrDefaultWithLambda(System.Type)">
            <summary>
            Enumerable.SingleOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableFirstOrDefault(System.Type)">
            <summary>
            Enumerable.FirstOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableFirstOrDefaultWithLambda(System.Type)">
            <summary>
            Enumerable.FirstOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableLastOrDefault(System.Type)">
            <summary>
            Enumerable.LastOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableLastOrDefaultWithLambda(System.Type)">
            <summary>
            Enumerable.LastOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableFirst(System.Type)">
            <summary>
            Enumerable.First без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableFirstWithLambda(System.Type)">
            <summary>
            Enumerable.First с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableLast(System.Type)">
            <summary>
            Enumerable.Last без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableLastWithLambda(System.Type)">
            <summary>
            Enumerable.Last с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableSingle(System.Type)">
            <summary>
            Enumerable.Single без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableSingleWithLambda(System.Type)">
            <summary>
            Enumerable.Single с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableGroupBy(System.Type,System.Type)">
            <summary>
            enumerable.GroupBy(e => e.Selector)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableToLookup(System.Type,System.Type)">
            <summary>
            enumerable.ToLookup(e => e.Selector)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableAsEnumerable(System.Type)">
            <summary>
            Enumerable.AsEnumerable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableEmpty(System.Type)">
            <summary>
            Enumerable.Empty
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableContains(System.Type)">
            <summary>
            Enumerable.Contains
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableAll(System.Type)">
            <summary>
            Enumerable.All
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableAny(System.Type)">
            <summary>
            Enumerable.Any без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableAnyWithLambda(System.Type)">
            <summary>
            Enumerable.Any с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableCount(System.Type)">
            <summary>
            Enumerable.Count без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumerableCountWithLambda(System.Type)">
            <summary>
            Enumerable.Count с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.ObjectToString">
            <summary> 
            Object.ToString
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringContains">
            <summary>
            String.Contains
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringStartsWith">
            <summary>
            String.StartsWith
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringEndsWith">
            <summary>
            String.EndsWith
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringTrim">
            <summary>
            String.Trim
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IenumeratorMoveNext">
            <summary>
            IEnumerator.MoveNext (IEnumerator - не генерик)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IdisposableDispose">
            <summary>
            IDisposable.Dispose
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringConcatTwo">
            <summary>
            String.Concat с двумя параметрами-строками
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringConcatThree">
            <summary>
            String.Concat с тремя параметрами-строками
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringConcatFour">
            <summary>
            String.Concat с четырьмя параметрами-строками
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringConcatArray">
            <summary>
            String.Concat с params
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringConcatTwoObjects">
            <summary>
            String.Concat с двумя параметрами-объектами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringConcatThreeObjects">
            <summary>
            String.Concat с тремя параметрами-объектами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringConcatFourObjects">
            <summary>
            String.Concat с четырьмя параметрами-объектами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringConcatArrayObjects">
            <summary>
            String.Concat с params объектов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringJoinEnumerableStrings">
            <summary>
            String.Join(string, IEnumerable{string})
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringJoinArrayStrings">
            <summary>
            String.Join(string, string[])
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringFormatOne">
            <summary>
            String.Format(string, object)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringFormatTwo">
            <summary>
            String.Format(string, object, object)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringFormatThree">
            <summary>
            String.Format(string, object, object, object)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringFormatArray">
            <summary>
            String.Format(string, object[])
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableWhere(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Where
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableSelect(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Select с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableSelectMany(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.SelectMany с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableToList(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.ToList
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableAny(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Any без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableCount(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Count без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableAnyWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Any с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableCountWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Count с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableToArray(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.ToArray
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableAsEnumerable(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.AsEnumerable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsQueryableAsQueryable(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Queryable.AsQueryable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringContains(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Contains
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringConcatTwo(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Concat с двумя параметрами (объектами или строками)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringConcatThree(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Concat с двумя параметрами (объектами или строками)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringConcatFour(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Concat с двумя параметрами (объектами или строками)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringConcatArray(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Concat с двумя параметрами (объектами или строками)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringStartsWith(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.StartsWith
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringEndsWith(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.EndsWith
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringIsNullOrEmpty(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.IsNullOrEmpty
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringTrim(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Trim
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringTrimWithParam(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Trim с параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringTrimEnd(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.TrimEnd
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringTrimStart(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.TrimStart
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringInsert(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Insert
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringRemove(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Remove с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringRemoveWithLength(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Remove с двумя параметрами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringSubstring(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Substring с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringSubstringWithLength(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Substring с двумя параметрами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringIndexOf(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.IndexOf с параметром-строкой
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringToLower(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.ToLower без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringToUpper(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.ToUpper без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringToLowerInvariant(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.ToLowerInvariant
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStringToUpperInvariant(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.ToUpperInvariant
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsObjectToString(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Object.ToString
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableAll(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.All
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableMax(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Max без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableMin(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Min без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableAvg(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Average без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableSum(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Sum без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableMaxWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Max с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableMinWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Min с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableAvgWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Average с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableSumWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Sum с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableContains(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Contains без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableFirstWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.First с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableFirstOrDefaultWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.FirstOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableLastWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Last с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableLastOrDefaultWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.LastOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableSingleWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Single с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableSingleOrDefaultWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.SingleOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableSingleOrDefault(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.SingleOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableFirst(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.First без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableFirstOrDefault(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.FirstOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableSingle(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Single без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableLast(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Last без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableLastOrDefault(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.LastOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumerableEmpty(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Empty
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.QueryableAsQueryable(System.Type)">
            <summary>
            Queryable.AsQueryable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringIsNullOrEmpty">
            <summary>
            String.IsNullOrEmpty
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringTrimWithParam">
            <summary>
            String.Trim(char[])
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringTrimStart">
            <summary>
            String.TrimStart
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringTrimEnd">
            <summary>
            String.TrimEnd
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringInsert">
            <summary>
            String.Insert
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringRemove">
            <summary>
            String.Remove(int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringRemoveWithLength">
            <summary>
            String.Remove(int, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringIndexOf">
            <summary>
            String.IndexOf(string)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringToLower">
            <summary>
            String.ToLower()
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringToUpper">
            <summary>
            String.ToUpper()
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringToLowerInvariant">
            <summary>
            String.ToLowerInvariant()
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringToUpperInvariant">
            <summary>
            String.ToUpperInvariant()
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringSubstring">
            <summary>
            String.Substring(int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.StringSubstringWithLength">
            <summary>
            String.Substring(int, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.EnumHasFlag">
            <summary>
            Enum.HasFlag(enum)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsEnumHasFlag(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enum.HasFlag(enum)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathPow">
            <summary>
            Math.Pow(double, double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsMathPow(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Pow(double, double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathTruncateDecimal">
            <summary>
            Math.Truncate(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathTruncateDouble">
            <summary>
            Math.Truncate(double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.DecimalTruncate">
            <summary>
            Decimal.Truncate(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStaticTruncate(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Truncate(decimal), Math.Truncate(double) или Decimal.Truncate(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathCeilingDecimal">
            <summary>
            Math.Ceiling(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathCeilingDouble">
            <summary>
            Math.Ceiling(double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.DecimalCeiling">
            <summary>
            Decimal.Ceiling(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStaticCeiling(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Ceiling(decimal), Math.Ceiling(double) или Decimal.Ceiling(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathFloorDecimal">
            <summary>
            Math.Floor(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathFloorDouble">
            <summary>
            Math.Floor(double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.DecimalFloor">
            <summary>
            Decimal.Floor(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStaticFloor(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Floor(decimal), Math.Floor(double) или Decimal.Floor(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathRoundDecimal">
            <summary>
            Math.Round(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathRoundDouble">
            <summary>
            Math.Round(double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.DecimalRound">
            <summary>
            Decimal.Round(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStaticRound(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Round(decimal), Math.Round(double) или Decimal.Round(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathRoundWithPrecisionDecimal">
            <summary>
            Math.Round(decimal, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathRoundWithPrecisionDouble">
            <summary>
            Math.Round(double, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.DecimalRoundWithPrecision">
            <summary>
            Decimal.Round(decimal, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsStaticRoundWithPrecision(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Round(decimal, int), Math.Round(double, int) или Decimal.Round(decimal, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.MathAbs(System.Type)">
            <summary>
            Math.Abs(number)
            </summary>
            <param name="type">Знаковый числовой тип</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary.IsMathAbs(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Abs
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.IMemberNamingHelper">
            <summary>
            Определяет именование специальных членов класса
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberNamingHelper.WriteableShadow(System.String)">
            <summary>
            Получить каноническое имя теневого свойства
            </summary>
            <param name="virtualPropertyWithoutSetter">Виртуальное свойство без сеттера</param>
            <returns>Имя теневого свойства с сеттером</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IMemberNamingHelper.GetShadowedName(System.String)">
            <summary>
            Получить имя затенённого свойства
            </summary>
            <param name="propertyName">Имя свойства</param>
            <returns>Имя затенённого свойства</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.IObjectClonemaker">
            <summary>
            Создаёт глубокие копии объектов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IObjectClonemaker.Clone``1(``0,System.Collections.Generic.IEnumerable{System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember}},TsSoft.Expressions.Models.Reflection.ClonedPropertyManager)">
            <summary>
            Создать глубокую копию объекта
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Объект</param>
            <param name="paths">Пути, по которым осуществляется глубокое копирование</param>
            <param name="manager">Настройки копирования</param>
            <returns>Копия</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IObjectClonemaker.Clone``1(``0,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{``0,System.Object}}},TsSoft.Expressions.Models.Reflection.ClonedPropertyManager)">
            <summary>
            Создать глубокую копию объекта
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Объект</param>
            <param name="paths">Пути, по которым осуществляется глубокое копирование</param>
            <param name="manager">Настройки копирования</param>
            <returns>Копия</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IObjectClonemaker.Clone``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember}},TsSoft.Expressions.Models.Reflection.ClonedPropertyManager)">
            <summary>
            Создать глубокую копию объекта
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="objects">Объекты</param>
            <param name="paths">Пути, по которым осуществляется глубокое копирование</param>
            <param name="manager">Настройки копирования</param>
            <returns>Копия</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.IObjectClonemaker.Clone``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{``0,System.Object}}},TsSoft.Expressions.Models.Reflection.ClonedPropertyManager)">
            <summary>
            Создать глубокую копию объекта
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="objects">Объекты</param>
            <param name="paths">Пути, по которым осуществляется глубокое копирование</param>
            <param name="manager">Настройки копирования</param>
            <returns>Копия</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.ITypeHelper">
            <summary>
            Хелпер для типов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ITypeHelper.GetCollectionUnderlyingType(System.Type)">
            <summary>
            IEnumerable[IEnumerable[IEnumerable[T]]] => T
            </summary>
            <param name="collectionType">IEnumerable[IEnumerable[IEnumerable[T]]]</param>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.MaterializedDelegateTypeDescription">
            <summary>
            Описание существующего типа делегата
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Reflection.MaterializedDelegateTypeDescription.DelegateType">
            <summary>
            Тип делегата
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MaterializedDelegateTypeDescription.#ctor(System.Collections.Generic.IEnumerable{System.Type},System.Type,System.Type)">
            <summary>
            Описание существующего типа делегата
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MaterializedDelegateTypeDescription.Equals(TsSoft.Expressions.Helpers.Reflection.MaterializedDelegateTypeDescription)">
            <summary>
            Равны ли описания
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MaterializedDelegateTypeDescription.GetHashCode">
            <summary>
            Хэш
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper">
            <summary>
            Выделяет члены типов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetMethodInfo(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить метод
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetMethodInfo(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Получить метод
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetMethodInfo``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Получить метод
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetMethodInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить метод
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetGenericDefinitionMethodInfo(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Получить заготовку генерик-метода
            </summary>
            <param name="expression">Выражение - вызов генерик-метода</param>
            <returns>Заготовка метода</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetGenericDefinitionMethodInfo``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Получить заготовку генерик-метода
            </summary>
            <param name="expression">Выражение - вызов генерик-метода</param>
            <returns>Заготовка метода</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetGenericDefinitionMethodInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить заготовку генерик-метода
            </summary>
            <param name="expression">Выражение - вызов генерик-метода</param>
            <returns>Заготовка метода</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetPropertyInfo(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить свойство
            </summary>
            <param name="expression">Выражение - обращение к свойству</param>
            <returns>Свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetPropertyInfo``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Получить свойство
            </summary>
            <param name="expression">Выражение - обращение к свойству</param>
            <returns>Свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetPropertyInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить свойство
            </summary>
            <param name="expression">Выражение - обращение к свойству</param>
            <returns>Свойство</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetFieldInfo(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить поле
            </summary>
            <param name="expression">Выражение - обращение к полю</param>
            <returns>Поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetFieldInfo``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Получить поле
            </summary>
            <param name="expression">Выражение - обращение к полю</param>
            <returns>Поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetFieldInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить поле
            </summary>
            <param name="expression">Выражение - обращение к полю</param>
            <returns>Поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetGenericClassMethod``1(System.Linq.Expressions.Expression{System.Action{``0}},System.Type[])">
            <summary>
            Получить метод генерик-класса
            </summary>
            <param name="expression">Выражение - вызов метода</param>
            <param name="genericParameters">Новые параметры для генерик-класса</param>
            <returns>Метод</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetConstructorInfo``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Получить конструктор
            </summary>
            <typeparam name="T">Конструируемый тип</typeparam>
            <param name="expression">Выражение - вызов конструктора</param>
            <returns>Конструктор</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetValueHoldingMember(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить свойство или поле
            </summary>
            <param name="expression">Выражение - обращение к свойству или полю</param>
            <returns>Свойство или поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetValueHoldingMember``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Получить свойство или поле
            </summary>
            <param name="expression">Выражение - обращение к свойству или полю</param>
            <returns>Свойство или поле</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoHelper.GetValueHoldingMember``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить свойство или поле
            </summary>
            <param name="expression">Выражение - обращение к свойству или полю</param>
            <returns>Свойство или поле</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary">
            <summary>
            Библиотека методов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper)">
            <summary>
            Библиотека методов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableSelect(System.Type,System.Type)">
            <summary>
            Enumerable.Select с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableSelectMany(System.Type,System.Type)">
            <summary>
            Enumerable.SelectMany с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableWhere(System.Type)">
            <summary>
            Enumerable.Where
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableToList(System.Type)">
            <summary>
            Enumerable.ToList
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableToArray(System.Type)">
            <summary>
            Enumerable.ToArray
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableSingleOrDefault(System.Type)">
            <summary>
            Enumerable.SingleOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableEmpty(System.Type)">
            <summary>
            Enumerable.Empty
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableEmpty(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Empty
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableSingleOrDefaultWithLambda(System.Type)">
            <summary>
            Enumerable.SingleOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.ObjectToString">
            <summary> 
            Object.ToString
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringContains">
            <summary>
            String.Contains
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IenumeratorMoveNext">
            <summary>
            IEnumerator.MoveNext (IEnumerator - не генерик)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IdisposableDispose">
            <summary>
            IDisposable.Dispose
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableWhere(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Where
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableSelect(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Select с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableSelectMany(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.SelectMany с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableToList(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.ToList
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableAny(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Any без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableCount(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Count без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableAnyWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Any с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableCountWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Count с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableAll(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.All
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableToArray(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.ToArray
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableAsEnumerable(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.AsEnumerable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsQueryableAsQueryable(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Queryable.AsQueryable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.QueryableAsQueryable(System.Type)">
            <summary>
            Queryable.AsQueryable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringContains(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Contains
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringConcatTwo(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Concat с двумя параметрами (объектами или строками)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringConcatThree(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Concat с тремя параметрами (объектами или строками)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringConcatFour(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Concat с четырьмя параметрами (объектами или строками)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringConcatArray(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Concat с params (объектов или строк)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringTrim(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Trim
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringTrimWithParam(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Trim с параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringTrimEnd(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.TrimEnd
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringTrimStart(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.TrimStart
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringInsert(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Insert
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringRemove(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Remove с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringRemoveWithLength(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Remove с двумя параметрами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringSubstring(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Substring с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringSubstringWithLength(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.Substring с двумя параметрами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringIndexOf(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.IndexOf с параметром-строкой
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringToLower(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.ToLower без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringToUpper(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.ToUpper без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringToLowerInvariant(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.ToLowerInvariant
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringToUpperInvariant(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.ToUpperInvariant
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsObjectToString(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Object.ToString
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringStartsWith(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.StartsWith
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringEndsWith(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.EndsWith
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStringIsNullOrEmpty(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод String.IsNullOrEmpty
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringIsNullOrEmpty">
            <summary>
            String.IsNullOrEmpty
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableMax(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Max без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableMin(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Min без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableAvg(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Average без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableSum(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Sum без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableMaxWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Max с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableMinWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Min с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableAvgWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Average с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableSumWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Sum с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableContains(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Contains без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableContains(System.Type)">
            <summary>
            Enumerable.Contains
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableAll(System.Type)">
            <summary>
            Enumerable.All
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableAny(System.Type)">
            <summary>
            Enumerable.Any без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableAnyWithLambda(System.Type)">
            <summary>
            Enumerable.Any с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableCount(System.Type)">
            <summary>
            Enumerable.Count без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableCountWithLambda(System.Type)">
            <summary>
            Enumerable.Count с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringStartsWith">
            <summary>
            String.StartsWith
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringEndsWith">
            <summary>
            String.EndsWith
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringConcatTwo">
            <summary>
            String.Concat с двумя параметрами-строками
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringConcatThree">
            <summary>
            String.Concat с тремя параметрами-строками
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringConcatFour">
            <summary>
            String.Concat с четырьмя параметрами-строками
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringConcatArray">
            <summary>
            String.Concat с params
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringConcatTwoObjects">
            <summary>
            String.Concat с двумя параметрами-объектами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringConcatThreeObjects">
            <summary>
            String.Concat с тремя параметрами-объектами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringConcatFourObjects">
            <summary>
            String.Concat с четырьмя параметрами-объектами
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringConcatArrayObjects">
            <summary>
            String.Concat с params объектов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringTrim">
            <summary>
            String.Trim без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringTrimWithParam">
            <summary>
            String.Trim(char[])
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringTrimStart">
            <summary>
            String.TrimStart
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringTrimEnd">
            <summary>
            String.TrimEnd
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringInsert">
            <summary>
            String.Insert
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringRemove">
            <summary>
            String.Remove(int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringRemoveWithLength">
            <summary>
            String.Remove(int, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringIndexOf">
            <summary>
            String.IndexOf(string)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringToLower">
            <summary>
            String.ToLower()
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringToUpper">
            <summary>
            String.ToUpper()
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringToLowerInvariant">
            <summary>
            String.ToLowerInvariant()
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringToUpperInvariant">
            <summary>
            String.ToUpperInvariant()
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringSubstring">
            <summary>
            String.Substring(int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringSubstringWithLength">
            <summary>
            String.Substring(int, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableFirstWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Enumerable.First с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableFirstOrDefaultWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Enumerable.FirstOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableSingleWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Enumerable.Single с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableSingleOrDefaultWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Enumerable.SingleOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableFirst(System.Reflection.MethodInfo)">
            <summary>
            Enumerable.First без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableFirstOrDefault(System.Reflection.MethodInfo)">
            <summary>
            Enumerable.FirstOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableSingle(System.Reflection.MethodInfo)">
            <summary>
            Enumerable.Single без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableSingleOrDefault(System.Reflection.MethodInfo)">
            <summary>
            Enumerable.SingleOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableFirstOrDefault(System.Type)">
            <summary>
            Enumerable.FirstOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableFirstOrDefaultWithLambda(System.Type)">
            <summary>
            Enumerable.FirstOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableFirst(System.Type)">
            <summary>
            Enumerable.First без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableFirstWithLambda(System.Type)">
            <summary>
            Enumerable.First с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableSingle(System.Type)">
            <summary>
            Enumerable.Single без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableSingleWithLambda(System.Type)">
            <summary>
            Enumerable.Single с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableLastOrDefault(System.Type)">
            <summary>
            Enumerable.LastOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableLastOrDefaultWithLambda(System.Type)">
            <summary>
            Enumerable.LastOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableLast(System.Type)">
            <summary>
            Enumerable.Last без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableLastWithLambda(System.Type)">
            <summary>
            Enumerable.Last с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableLastWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Last с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableLastOrDefaultWithLambda(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.LastOrDefault с одним параметром
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableLast(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.Last без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumerableLastOrDefault(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enumerable.LastOrDefault без параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringJoinEnumerableStrings">
            <summary>
            String.Join(string, IEnumerable{string})
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringJoinArrayStrings">
            <summary>
            String.Join(string, string[])
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringFormatOne">
            <summary>
            String.Format("{0}", obj)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringFormatTwo">
            <summary>
            String.Format("{0} {1}", obj1, obj2)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringFormatThree">
            <summary>
            String.Format(string, object, object, object)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.StringFormatArray">
            <summary>
            String.Format(string, object[])
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableGroupBy(System.Type,System.Type)">
            <summary>
            enumerable.GroupBy(e => e.Selector)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableToLookup(System.Type,System.Type)">
            <summary>
            enumerable.ToLookup(e => e.Selector)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumerableAsEnumerable(System.Type)">
            <summary>
            Enumerable.AsEnumerable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.EnumHasFlag">
            <summary>
            Enum.HasFlag(enum)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsEnumHasFlag(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Enum.HasFlag(enum)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathPow">
            <summary>
            Math.Pow(double, double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsMathPow(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Pow(double, double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathTruncateDecimal">
            <summary>
            Math.Truncate(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathTruncateDouble">
            <summary>
            Math.Truncate(double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.DecimalTruncate">
            <summary>
            Decimal.Truncate(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStaticTruncate(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Truncate(decimal), Math.Truncate(double) или Decimal.Truncate(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathCeilingDecimal">
            <summary>
            Math.Ceiling(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathCeilingDouble">
            <summary>
            Math.Ceiling(double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.DecimalCeiling">
            <summary>
            Decimal.Ceiling(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStaticCeiling(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Ceiling(decimal), Math.Ceiling(double) или Decimal.Ceiling(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathFloorDecimal">
            <summary>
            Math.Floor(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathFloorDouble">
            <summary>
            Math.Floor(double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.DecimalFloor">
            <summary>
            Decimal.Floor(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStaticFloor(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Floor(decimal), Math.Floor(double) или Decimal.Floor(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathRoundDecimal">
            <summary>
            Math.Round(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathRoundDouble">
            <summary>
            Math.Round(double)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.DecimalRound">
            <summary>
            Decimal.Round(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStaticRound(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Round(decimal), Math.Round(double) или Decimal.Round(decimal)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathRoundWithPrecisionDecimal">
            <summary>
            Math.Round(decimal, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathRoundWithPrecisionDouble">
            <summary>
            Math.Round(double, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.DecimalRoundWithPrecision">
            <summary>
            Decimal.Round(decimal, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsStaticRoundWithPrecision(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Round(decimal, int), Math.Round(double, int) или Decimal.Round(decimal, int)
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.MathAbs(System.Type)">
            <summary>
            Math.Abs(number)
            </summary>
            <param name="type">Знаковый числовой тип</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberInfoLibrary.IsMathAbs(System.Reflection.MethodInfo)">
            <summary>
            Является ли метод Math.Abs
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.MemberNamingHelper">
            <summary>
            Определяет именование специальных членов класса
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberNamingHelper.GetShadowedName(System.String)">
            <summary>
            Получить имя затенённого свойства
            </summary>
            <param name="propertyName">Имя свойства</param>
            <returns>Имя затенённого свойства</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.MemberNamingHelper.WriteableShadow(System.String)">
            <summary>
            Получить каноническое имя теневого свойства
            </summary>
            <param name="virtualPropertyWithoutSetter">Виртуальное свойство без сеттера</param>
            <returns>Имя теневого свойства с сеттером</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.ObjectClonemaker">
            <summary>
            Создаёт глубокие копии объектов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ObjectClonemaker.#ctor(TsSoft.Expressions.Helpers.IFlatPathParser,TsSoft.Expressions.Helpers.Reflection.IMemberInfoHelper,TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary)">
            <summary>
            Создаёт глубокие копии объектов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ObjectClonemaker.Clone``1(``0,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{``0,System.Object}}},TsSoft.Expressions.Models.Reflection.ClonedPropertyManager)">
            <summary>
            Создать глубокую копию объекта
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Объект</param>
            <param name="paths">Пути, по которым осуществляется глубокое копирование</param>
            <param name="manager">Настройки копирования</param>
            <returns>Копия</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ObjectClonemaker.Clone``1(``0,System.Collections.Generic.IEnumerable{System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember}},TsSoft.Expressions.Models.Reflection.ClonedPropertyManager)">
            <summary>
            Создать глубокую копию объекта
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Объект</param>
            <param name="paths">Пути, по которым осуществляется глубокое копирование</param>
            <param name="manager">Настройки копирования</param>
            <returns>Копия</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ObjectClonemaker.Clone``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{``0,System.Object}}},TsSoft.Expressions.Models.Reflection.ClonedPropertyManager)">
            <summary>
            Создать глубокую копию объекта
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="objects">Объекты</param>
            <param name="paths">Пути, по которым осуществляется глубокое копирование</param>
            <param name="manager">Настройки копирования</param>
            <returns>Копия</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.ObjectClonemaker.Clone``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IReadOnlyList{TsSoft.Expressions.Models.ValueHoldingMember}},TsSoft.Expressions.Models.Reflection.ClonedPropertyManager)">
            <summary>
            Создать глубокую копию объекта
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="objects">Объекты</param>
            <param name="paths">Пути, по которым осуществляется глубокое копирование</param>
            <param name="manager">Настройки копирования</param>
            <returns>Копия</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Reflection.TypeExtensions">
            <summary>
            Расширения типа
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.IsNullableStruct(System.Type)">
            <summary>
            Является ли Nullable[T]
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.NullableStructUnderlyingType(System.Type)">
            <summary>
            Получить T из Nullable[T]
            </summary>
            <returns>Генерик-параметр Nullable[T], если аргумент является Nullable[T], в противном случае - аргумент</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.GetGenericEnumerableInterfaces(System.Type)">
            <summary>
            Получить все интерфейсы IEnumerable[T], реализуемые типом
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.IsGenericEnumerable(System.Type)">
            <summary>
            Реализует ли тип IEnumerable[T]; string не считается IEnumerable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.GetGenericEnumerableArgument(System.Type)">
            <summary>
            Получить T по IEnumerable[T]
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.GetGenericEnumerableArgumentOrSelf(System.Type)">
            <summary>
            Получить T по IEnumerable[T]; себя для типов, не реализующих IEnumerable
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.IsReferenceType(System.Type)">
            <summary>
            Является ли ссылочным типом
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.IsReferenceNotStringType(System.Type)">
            <summary>
            Является ли ссылочным типом, отличным от string
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.IsNullableType(System.Type)">
            <summary>
            Содержит ли null в множестве возможных значений
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Reflection.TypeExtensions.TryGetNullableParameter(System.Type,System.Type@)">
            <summary>
                Попытаться получить тип T из Nullable{T}
            </summary>
            <param name="type">Исходный тип</param>
            <param name="valueType">Результирующий тип T или null, если исходный тип не Nullable{T}</param>
            <returns>Является ли исходный тип Nullable{T}</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.TypeArrayComparer">
            <summary>
            Сравнивает массивы типов на поэлементное равенство
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.TypeArrayComparer.Instance">
            <summary>
            Сравнивает массивы типов на поэлементное равенство
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.TypeArrayComparer.Equals(System.Type[],System.Type[])">
            <summary>
            Совпадают ли массивы типов поэлементно
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.TypeArrayComparer.GetHashCode(System.Type[])">
            <summary>
            Хэш-код
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.ParseAndAddPossiblePath(System.Linq.Expressions.Expression)">
            <summary>
            Выделить путь, вставить where not null перед Select и SelectMany, добавить путь в набор путей
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitExtension(System.Linq.Expressions.Expression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionElementParserVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor">
            <summary>
            Обходчик выражения-условия, выделяющий используемые пути
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.Parse(System.Linq.Expressions.LambdaExpression,TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary,TsSoft.Expressions.Helpers.IExpressionBuilder,TsSoft.Expressions.Models.Multidictionary{System.Linq.Expressions.ParameterExpression,TsSoft.Expressions.Models.Path.ParsedPath},System.Reflection.MethodInfo)">
            <summary>
            Выделить используемые пути из выражения с условием
            </summary>
            <param name="condition">Выражение с условием</param>
            <param name="library">Библиотека методов</param>
            <param name="expressionBuilder">Построитель выражений</param>
            <param name="branches">Ветвления пути</param>
            <param name="method">Метод, в котором используется условие</param>
            <returns>Модель условия</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary,TsSoft.Expressions.Helpers.IExpressionBuilder,TsSoft.Expressions.Models.Multidictionary{System.Linq.Expressions.ParameterExpression,TsSoft.Expressions.Models.Path.ParsedPath})">
            <summary>
            Обходчик выражения-условия, выделяющий используемые пути
            </summary>
            <param name="library">Библиотека методов</param>
            <param name="expressionBuilder">Построитель выражений</param>
            <param name="branches">Ветвления пути</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
            <summary>
            Посетить узел обращения к члену
            </summary>
            <param name="node">Узел</param>
            <returns>Перестроенный узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Посетить узел вызова метода
            </summary>
            <param name="node">Узел</param>
            <returns>Перестроенный узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Посетить узел унарной операции
            </summary>
            <param name="node">Узел</param>
            <returns>Перестроенный узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Посетить узел бинарной операции
            </summary>
            <param name="node">Узел</param>
            <returns>Перестроенный узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
            <summary>
            Посетить узел бинарной операции с типами
            </summary>
            <param name="node">Узел</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <summary>
            Посетить узел бинарной операции с типами
            </summary>
            <param name="node">Узел</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <summary>
            Посетить узел с константой
            </summary>
            <param name="node">Узел</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Посетить узел с параметром
            </summary>
            <param name="node">Узел</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitExtension(System.Linq.Expressions.Expression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConditionParserVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
            <summary>
            Выбросить исключение на недопустимом в условии узле
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionFinderVisitor">
            <summary>
            Ищет в выражении константы заданных типов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionFinderVisitor.GetConstants(System.Linq.Expressions.Expression,System.Func{System.Type,System.Boolean})">
            <summary>
            Получить все константы ссылочных типов, содержащиеся в выражении
            </summary>
            <param name="expression">Выражение</param>
            <param name="predicate">Константы каких типов выбирать (по умолчанию - ссылочные типы, отличные от <see cref="T:System.String"/> и <see cref="T:System.Type"/></param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionFinderVisitor.GetConstants``1(System.Linq.Expressions.Expression{``0},System.Func{System.Type,System.Boolean})">
            <summary>
            Получить все константы ссылочных типов, содержащиеся в выражении
            </summary>
            <param name="expression">Выражение</param>
            <param name="predicate">Константы каких типов выбирать (по умолчанию - ссылочные типы, отличные от <see cref="T:System.String"/> и <see cref="T:System.Type"/></param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionFinderVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <summary>
            Обработать узел с константой
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionReplacerVisitor">
            <summary>
            Заменяет константы в выражении
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionReplacerVisitor.ReplaceConstants(System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyDictionary{System.Object,System.Linq.Expressions.Expression})">
            <summary>
            Заменить константы в выражении
            </summary>
            <param name="expression">Выражение</param>
            <param name="replacements">Замены для констант</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionReplacerVisitor.ReplaceConstants``1(System.Linq.Expressions.Expression{``0},System.Collections.Generic.IReadOnlyDictionary{System.Object,System.Linq.Expressions.Expression})">
            <summary>
            Заменить константы в выражении
            </summary>
            <param name="expression">Выражение</param>
            <param name="replacements">Замены для констант</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionReplacerVisitor.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ConstantExpressionReplacerVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <summary>
            Обработать узел с константой
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.EntityCastInterfaceRemoverVisitor">
            <summary>
            Обходчик выражения, удаляющий приведения к интерфейсам
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.EntityCastInterfaceRemoverVisitor.Convert``1(``0)">
            <summary>
            Удалить приведения к интерфейсам
            </summary>
            <typeparam name="TExpression">Тип выражения</typeparam>
            <param name="predicate">Выражение</param>
            <returns>Преобразованное выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.EntityCastInterfaceRemoverVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Посетить узел с унарной операцией
            </summary>
            <param name="node">Узел</param>
            <returns>Изменённый узел</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.FlatPathParserVisitor">
            <summary>
            Обходчик выражения, выделяющий линейный путь
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.FlatPathParserVisitor.GetMemberCollection(System.Linq.Expressions.Expression)">
            <summary>
            Получить линейный путь по выражению
            </summary>
            <param name="expression">Выражение</param>
            <returns>Линейный путь</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.FlatPathParserVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Посетить узел с вызовом метода
            </summary>
            <param name="node">Узел</param>
            <returns>Значение не определено</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.FlatPathParserVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
            <summary>
            Посетить узел с обращением к члену
            </summary>
            <param name="node">Узел</param>
            <returns>Значение не определено</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor">
            <summary>
            Обходчик выражений для обрезания инклюдов
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor.#ctor(System.Func{TsSoft.Expressions.Models.ValueHoldingMember,System.Boolean})">
            <summary>
            Обходчик выражений для обрезания инклюдов
            </summary>
            <param name="stopOn">Предикат необходимости обрезать инклюд</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor.GetExternalMember">
            <summary>
            Получить свойство внешней сущности
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor.GetExternalEntityType">
            <summary>
            Получить тип внешней сущности, на свойстве с которой был обрезан инклюд
            </summary>
            <returns>Тип внешней сущности</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor.GetDeclaringEntityType">
            <summary>
            Получить тип сущности, на свойстве которой был обрезан инклюд
            </summary>
            <returns>Тип-контейнер с внешней сущностью</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
            <summary>
            Посетить узел с обращением к члену
            </summary>
            <param name="node">Узел</param>
            <returns>Преобразованный узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Посетить узел с вызовом метода
            </summary>
            <param name="node">Узел</param>
            <returns>Преобразованный узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Посетить узел-лямбду
            </summary>
            <typeparam name="TDelegate">Тип делегата лямбды</typeparam>
            <param name="node">Узел</param>
            <returns>Преобразованный узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionCutterVisitor.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionEntitiesSelectorVisitor`1">
            <summary>
            Обходчик выражений, преобразующий коллекцию объектов согласно линейному пути
            </summary>
            <typeparam name="T">Тип входа пути</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionEntitiesSelectorVisitor`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{TsSoft.Expressions.Models.ValueHoldingMember,System.Boolean})">
            <summary>
            Обходчик выражений, преобразующий коллекцию объектов согласно линейному пути
            </summary>
            <param name="entityCollection">Входные объекты</param>
            <param name="stopOn">Предикат остановки</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionEntitiesSelectorVisitor`1.GetCurrentState">
            <summary>
            Получить текущее состояние обходчика
            </summary>
            <returns>Коллекция объектов, обозреваемая обходчиком</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionEntitiesSelectorVisitor`1.GetCurrentType">
            <summary>
            Получить тип элементов текущего состояния обходчика
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionEntitiesSelectorVisitor`1.GetExternalProperty">
            <summary>
            Получить свойство, на котором произошла остановка
            </summary>
            <returns>Свойство, на котором произошла остановка</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionEntitiesSelectorVisitor`1.VisitMember(System.Linq.Expressions.MemberExpression)">
            <summary>
            Посетить узел обращения к члену
            </summary>
            <param name="node">Узел</param>
            <returns>Значение не определено</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.IncludeExpressionEntitiesSelectorVisitor`1.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Посетить узел вызова метода
            </summary>
            <param name="node">Узел</param>
            <returns>Значение не определено</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor">
            <summary>
            Компилирует лямбду, предварительно компилируя встречающиеся в ней внутренние лямбды
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor.Compile``1(System.Linq.Expressions.Expression{``0},TsSoft.Expressions.Helpers.Closures.LambdaCompilationType,TsSoft.Expressions.Helpers.Closures.IInnerLambdaCompiler,TsSoft.Expressions.Helpers.Closures.ISpecialInnerLambdaCompiler,TsSoft.Expressions.Helpers.Closures.IMethodBuilderLambdaCompiler)">
            <summary>
            Компилировать лямбду, предварительно скомпилировав встречающиеся в ней внутренние лямбды
            </summary>
            <typeparam name="T">Тип делегата лямбды</typeparam>
            <param name="expr">Лямбда</param>
            <param name="compilationType">Тип компиляции</param>
            <param name="innerLambdaCompiler">Компилятор лямбд</param>
            <param name="specialInnerLambdaCompiler">Компилятор лямбд</param>
            <param name="methodBuilderLambdaCompiler">Компилятор лямбд</param>
            <returns>Делегат</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor.Compile(System.Linq.Expressions.LambdaExpression,TsSoft.Expressions.Helpers.Closures.LambdaCompilationType,TsSoft.Expressions.Helpers.Closures.IInnerLambdaCompiler,TsSoft.Expressions.Helpers.Closures.ISpecialInnerLambdaCompiler,TsSoft.Expressions.Helpers.Closures.IMethodBuilderLambdaCompiler)">
            <summary>
            Компилировать лямбду, предварительно скомпилировав встречающиеся в ней внутренние лямбды
            </summary>
            <param name="expr">Лямбда</param>
            <param name="compilationType">Тип компиляции</param>
            <param name="innerLambdaCompiler">Компилятор лямбд</param>
            <param name="specialInnerLambdaCompiler">Компилятор лямбд</param>
            <param name="methodBuilderLambdaCompiler">Компилятор лямбд</param>
            <returns>Делегат</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor.#ctor(TsSoft.Expressions.Helpers.Closures.LambdaCompilationType,TsSoft.Expressions.Helpers.Closures.IInnerLambdaCompiler,TsSoft.Expressions.Helpers.Closures.ISpecialInnerLambdaCompiler)">
            <summary>
            Компилирует лямбду, предварительно компилируя встречающиеся в ней внутренние лямбды
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor.CompileInnerLambdas``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Компилировать встречающиеся в лямбде лямбда-аргументы методов без открытых параметров
            </summary>
            <typeparam name="T">Тип делегата лямбды</typeparam>
            <param name="expr">Лямбда</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor.CompileInnerLambdas(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Компилировать встречающиеся в лямбде лямбда-аргументы методов без открытых параметров
            </summary>
            <param name="expr">Лямбда</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Обойти выражение, компилируя встречающиеся в нём лямбда-аргументы методов без открытых параметров
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.InnerLambdaCompilerVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Обойти узел
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.NBool">
            <summary>
            Значение трёхзначной логики
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Visitors.NBool.True">
            <summary>
            true
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Visitors.NBool.False">
            <summary>
            false
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Visitors.NBool.Null">
            <summary>
            null
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Visitors.NBool.TrueExpr">
            <summary>
            Выражение с константой true
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Visitors.NBool.FalseExpr">
            <summary>
            Выражение с константой false
            </summary>
        </member>
        <member name="F:TsSoft.Expressions.Helpers.Visitors.NBool.NullExpr">
            <summary>
            Выражение с константой null
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.MakeNBoolExpression(TsSoft.Expressions.Models.Path.ExpressionWithPrecondition)">
            <summary>
            Собрать трёхзначное выражение из выражение с предусловием
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Visitors.NBool.IsNull">
            <summary>
            Является ли null
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Visitors.NBool.IsTrue">
            <summary>
            Является ли true
            </summary>
        </member>
        <member name="P:TsSoft.Expressions.Helpers.Visitors.NBool.IsFalse">
            <summary>
            Является ли false
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_Implicit(System.Boolean)~TsSoft.Expressions.Helpers.Visitors.NBool">
            <summary>
            Приведение <see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_Implicit(System.Nullable{System.Boolean})~TsSoft.Expressions.Helpers.Visitors.NBool">
            <summary>
            Приведение <see cref="T:System.Nullable`1"/>
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_Implicit(TsSoft.Expressions.Helpers.Visitors.NBool)~System.Nullable{System.Boolean}">
            <summary>
            Приведение к <see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_LogicalNot(TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Отрицание
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_True(TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Является ли true
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_False(TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Является ли false
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_BitwiseAnd(TsSoft.Expressions.Helpers.Visitors.NBool,TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Конъюнкция
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_BitwiseOr(TsSoft.Expressions.Helpers.Visitors.NBool,TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Дизъюнкция
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_OnesComplement(TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Отрицание
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_ExclusiveOr(TsSoft.Expressions.Helpers.Visitors.NBool,TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Сложение по модулю 2
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_Equality(TsSoft.Expressions.Helpers.Visitors.NBool,TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Проверка на равенство
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.op_Inequality(TsSoft.Expressions.Helpers.Visitors.NBool,TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Проверка на неравенство
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.Equals(System.Object)">
            <summary>
            Проверка на равенство
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.Equals(TsSoft.Expressions.Helpers.Visitors.NBool)">
            <summary>
            Проверка на равенство
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.GetHashCode">
            <summary>
            Хэш
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NBool.ToString">
            <summary>
            Строковое представление
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.NewExpressionTypeUniquenessChecker">
            <summary>
            Обходчик выражений, проверяющий уникальность типов в NewExpression внутри выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NewExpressionTypeUniquenessChecker.Check(System.Linq.Expressions.Expression)">
            <summary>
            Проверить уникальность типов в NewExpression внутри выражения
            </summary>
            <param name="checkedExpr">Проверяемое выражение</param>
            <returns>Тип, конструктор которого дважды встречается в выражении, или null, если такого нет</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.NewExpressionTypeUniquenessChecker.VisitNew(System.Linq.Expressions.NewExpression)">
            <summary>
            Посетить узел-конструктор
            </summary>
            <param name="node">Узел</param>
            <returns>Тот же узел</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.OpenLambdaParameterFinderVisitor">
            <summary>
            Находит в лямбде несобственные параметры
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.OpenLambdaParameterFinderVisitor.GetParameters(System.Linq.Expressions.Expression)">
            <summary>
            Получить параметры, встерчающиеся в выражении и не являющиеся внутренними параметрами лямбд
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.OpenLambdaParameterFinderVisitor.GetOpenParameters(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Получить несобственные параметры, встречающиеся в лямбде
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.OpenLambdaParameterFinderVisitor.GetOpenParameters``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Получить несобственные параметры, встречающиеся в лямбде
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.OpenLambdaParameterFinderVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.OpenLambdaParameterFinderVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.OpenLambdaParameterFinderVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor">
            <summary>
            Обходчик выражений, заменяющий параметры лямбды
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.#ctor(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Создать обходчик выражений, заменяющий параметр лямбды
            </summary>
            <param name="inner">На что заменять параметр</param>
            <param name="parameter">Заменяемый параметр</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression}})">
            <summary>
            Создать обходчик выражений, заменяющий параметры лямбды
            </summary>
            <param name="replacements">Параметры и на что их заменять</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.Replace(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Заменить вхождения параметра в выражение
            </summary>
            <param name="source">Исходное выражение</param>
            <param name="parameter">Заменяемый параметр</param>
            <param name="replacement">Заменитель</param>
            <returns>Изменённое выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.ReplaceInBody(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Заменить вхождения параметра в тело лямбды
            </summary>
            <param name="source">Исходное выражение</param>
            <param name="parameter">Заменяемый параметр</param>
            <param name="replacement">Заменитель</param>
            <returns>Изменённое выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.ReplaceInBody``1(System.Linq.Expressions.Expression{``0},System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Заменить вхождения параметра в тело лямбды
            </summary>
            <param name="source">Исходное выражение</param>
            <param name="parameter">Заменяемый параметр</param>
            <param name="replacement">Заменитель</param>
            <returns>Изменённое выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.Replace(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression}})">
            <summary>
            Заменить вхождения параметра в выражение
            </summary>
            <param name="source">Исходное выражение</param>
            <param name="replacements">Какие параметры заменять, на что</param>
            <returns>Изменённое выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.ReplaceInBody(System.Linq.Expressions.LambdaExpression,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression}})">
            <summary>
            Заменить вхождения параметра в тело лямбды
            </summary>
            <param name="source">Исходное выражение</param>
            <param name="replacements">Какие параметры заменять, на что</param>
            <returns>Изменённое выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.ReplaceInBody``1(System.Linq.Expressions.Expression{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression}})">
            <summary>
            Заменить вхождения параметра в тело лямбды
            </summary>
            <param name="source">Исходное выражение</param>
            <param name="replacements">Какие параметры заменять, на что</param>
            <returns>Изменённое выражение</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Посетить узел-параметр
            </summary>
            <param name="node">Узел</param>
            <returns>Заменённый узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Посетить узел-лямбду
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <summary>
            Посетить узел-блок
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterReplacerVisitor.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.ParameterTypeReplacerVisitor`1">
            <summary>
            Заменяет тип параметра лямбды
            </summary>
            <typeparam name="TParameterInterface">Исходный тип параметра</typeparam>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterTypeReplacerVisitor`1.#ctor(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Создать заменитель типа параметра лямбды
            </summary>
            <param name="parameter">Параметр-заменитель</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterTypeReplacerVisitor`1.VisitMember(System.Linq.Expressions.MemberExpression)">
            <summary>
            Посетить узел обращения к члену
            </summary>
            <param name="node">Узел</param>
            <returns>Преобразованный узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ParameterTypeReplacerVisitor`1.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Посетить узел параметра
            </summary>
            <param name="node">Узел</param>
            <returns>Преобразованный узел</returns>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor">
            <summary>
            Разбирает выражения пути:
            1) константа - пустой путь
            2) выражения вида p.A.B.Select(b => b.C).SelectMany(c => c.D).Where(d => P(d))
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.Parse(System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary,TsSoft.Expressions.Helpers.IExpressionBuilder)">
            <summary>
            Извлекает путь из выражения
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.ParseAndConvert(System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary,TsSoft.Expressions.Helpers.IExpressionBuilder,System.Linq.Expressions.Expression@)">
            <summary>
            Извлекает путь из выражения, добавляя Where(x => x != null) перед каждым вызовом Select и SelectMany
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.TryParseAndConvert(System.Linq.Expressions.Expression,TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary,TsSoft.Expressions.Helpers.IExpressionBuilder,TsSoft.Expressions.Models.Multidictionary{System.Linq.Expressions.ParameterExpression,TsSoft.Expressions.Models.Path.ParsedPath},System.Linq.Expressions.Expression@)">
            <summary>
            Извлекает путь из выражения, если он там есть, добавляя Where(x => x != null) перед каждым вызовом Select и SelectMany
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary,TsSoft.Expressions.Helpers.IExpressionBuilder)">
            <summary>
            Разбирает выражения пути:
            1) константа - пустой путь
            2) выражения вида p.A.B.Select(b => b.C).SelectMany(c => c.D).Where(d => P(d))
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.#ctor(TsSoft.Expressions.Helpers.Reflection.IMemberInfoLibrary,TsSoft.Expressions.Helpers.IExpressionBuilder,TsSoft.Expressions.Models.Multidictionary{System.Linq.Expressions.ParameterExpression,TsSoft.Expressions.Models.Path.ParsedPath})">
            <summary>
            Разбирает выражения пути:
            1) константа - пустой путь
            2) выражения вида p.A.B.Select(b => b.C).SelectMany(c => c.D).Where(d => P(d))
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Посетить узел
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.SetStartParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Установить начальный параметр
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Посетить узел с вызовом метода, обработать часть пути внутри Select и SelectMany, условие внутри Where
            </summary>
            <param name="node">Узел</param>
            <returns>Узел с перестроенным условием и проверкой на null</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
            <summary>
            Посетить узел с обращением к члену, обработать часть пути для членов-свойств
            </summary>
            <param name="node">Узел</param>
            <returns>Тот же узел</returns>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitExtension(System.Linq.Expressions.Expression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Посетить узел с лямбда-выражением, обработать часть пути
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Выбросить исключение на недопустимом в пути узле или пропустить Convert
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.PathParserVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
            <summary>
            Выбросить исключение на недопустимом в пути узле
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Helpers.Visitors.ReusedParameterFinderVisitor">
            <summary>
            Находит параметры, встречающиеся в теле лямбды более одного раза
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ReusedParameterFinderVisitor.FindReusedParameters(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Найти параметры, встречающиеся в теле лямбды более одного раза
            </summary>
            <param name="expression">Лямбда</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ReusedParameterFinderVisitor.FindReusedParameters``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Найти параметры, встречающиеся в теле лямбды более одного раза
            </summary>
            <param name="expression">Лямбда</param>
        </member>
        <member name="M:TsSoft.Expressions.Helpers.Visitors.ReusedParameterFinderVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Обработать параметр
            </summary>
        </member>
        <member name="T:TsSoft.Expressions.Models.Differences.ObjectDiffExtensions">
            <summary>
            Расширения различий в объектах
            </summary>
        </member>
        <member name="M:TsSoft.Expressions.Models.Differences.ObjectDiffExtensions.PrimitiveDiff``2(TsSoft.Expressions.Models.Differences.IObjectDiff{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить различие в значениях простого свойства объекта
            </summary>
            <typeparam name="TProp">Тип значения свойства</typeparam>
            <typeparam name="T">Тип сравнённого объекта</typeparam>
            <param name="objectDiff">Результат сравнения</param>
            <param name="path">Свойство</param>
            <returns>Различие в значениях свойства или null, если различий нет</returns>
        </member>
        <member name="M:TsSoft.Expressions.Models.Differences.ObjectDiffExtensions.SubobjectDiff``2(TsSoft.Expressions.Models.Differences.IObjectDiff{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Получить различие в значениях простого свойства объекта
            </summary>
            <typeparam name="TProp">Тип значения свойства</typeparam>
            <typeparam name="T">Тип сравнённого объекта</typeparam>
            <param name="objectDiff">Результат сравнения</param>
            <param name="path">Свойство</param>
            <returns>Различие в значениях свойства или null, если различий нет</returns>
        </member>
        <member name="M:TsSoft.Expressions.Models.Differences.ObjectDiffExtensions.CollectionDiff``2(TsSoft.Expressions.Models.Differences.IObjectDiff{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Получить различие в значениях простого свойства объекта
            </summary>
            <typeparam name="TPropElem">Тип значения элемента свойства</typeparam>
            <typeparam name="T">Тип сравнённого объекта</typeparam>
            <param name="path">Свойство</param>
            <param name="objectDiff">Результат сравнения</param>
            <returns>Различие в значениях свойства или null, если различий нет</returns>
        </member>
        <member name="T:TsSoft.Bindings.ExpressionsHelpersBindings">
            <summary>
            Описание интерфейсов и их реализаций в сборке TsSoft.Expressions.Helpers
            </summary>
        </member>
        <member name="M:TsSoft.Bindings.ExpressionsHelpersBindings.#ctor">
            <summary>
            Описание интерфейсов и их реализаций в сборке TsSoft.Expressions.Helpers
            </summary>
        </member>
    </members>
</doc>
